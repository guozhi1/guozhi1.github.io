[{"content":"一、WidnowsHOOK分类 系统钩子（System Hooks）：系统钩子是最常见的一类钩子，用于监视和修改系统级别的事件。系统钩子可以捕获和处理各种系统事件，如键盘输入、鼠标消息、窗口消息等。系统钩子可以全局范围内生效，可以对整个系统中的事件进行拦截和处理。\n应用程序钩子（Application Hooks）：应用程序钩子是针对特定应用程序的钩子，用于监视和修改特定应用程序的行为。应用程序钩子可以捕获和处理应用程序级别的事件，如窗口消息、菜单消息、定时器消息等。应用程序钩子只对指定的应用程序生效。\n线程钩子（Thread Hooks）：线程钩子是针对特定线程的钩子，用于监视和修改特定线程的行为。线程钩子可以捕获和处理特定线程的事件，如窗口消息、键盘输入等。线程钩子只对指定的线程生效。\n子类钩子（Subclass Hooks）：子类钩子是一种特殊的钩子，用于修改指定窗口类的消息处理函数。通过子类钩子，可以在不修改原始窗口类的情况下，对窗口消息进行自定义处理。\nWH_CALLWNDPROC钩子：这是一种特殊的系统钩子，用于监视和修改窗口消息的处理过程。WH_CALLWNDPROC钩子可以拦截和处理窗口消息的传递过程，允许对消息进行修改或拦截。\n二、设键盘钩子钩子 1. SetWindowsHook可以HOOK类型 WH_KEYBOARD（键盘钩子）：用于监视和处理键盘输入事件，可以拦截和修改键盘输入。 WH_MOUSE（鼠标钩子）：用于监视和处理鼠标事件，包括鼠标移动、按下和释放鼠标按键等。 WH_KEYBOARD_LL（低级键盘钩子）：与WH_KEYBOARD类似，但是是一个低级别的钩子，可以全局拦截键盘输入。 WH_MOUSE_LL（低级鼠标钩子）：与WH_MOUSE类似，但是是一个低级别的钩子，可以全局监视鼠标事件。 WH_CALLWNDPROC（窗口消息钩子）：用于监视和处理窗口消息，可以拦截和修改窗口消息的传递。 WH_GETMESSAGE（消息钩子）：用于监视和处理消息队列中的消息，可以拦截和修改消息的传递。 2. 从零写一个键盘HOOK 首先需要的函数有\nSetWindowsHookEx设置一个HOOK\nHHOOK SetWindowsHookExA( [in] int idHook, //选择HOOK的目标 [in] HOOKPROC lpfn, //回调函数 [in] HINSTANCE hmod, //过于抽象 [in] DWORD dwThreadId //选择一个线程0是全局 ); 回调函数HOOK到之后需要执行的流程\nRESULT CALLBACK是一种函数类型，它是Windows API中定义的一种回调函数类型。 参数是由SetWindowsHook给的\nRESULT CALLBACK HookTest( int nCode, //接收事件状态 WPARAM wParam, //wParam表示键盘事件的消息标识符 LPARAM lParam, //按下的键的虚拟键码、扫描码、扩展键标志等。 ); GetMessage 用于从消息队列中获取一个消息\nBOOL GetMessage( [out] LPMSG lpMsg, //从线程队列接收消息 [in, optional] HWND hWnd, //NULL检测所有线程窗口， -1只接受当前线程消息 [in] UINT wMsgFilterMin, //要检索的最低消息值的整数值 [in] UINT wMsgFilterMax //要检索的最高消息值的整数值 ); PostQuitMessage 发送一个退出消息\nvoid PostQuitMessage( [in] int nExitCode ); UnhookWindowsHookEx 结束HOOK\nBOOL UnhookWindowsHookEx( [in] HHOOK hhk //要结束的HOOK ); C++ 代码示例\n#include \u0026lt;Windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; //钩子函数 LRESULT CALLBACK KeyboardHookCallback(int nCode, WPARAM wParam, LPARAM lParam) {\tif (nCode \u0026gt;= 0) { KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; //获取按下的键的虚拟键码、扫描码、扩展键标志等。 if (wParam == WM_KEYDOWN) //键盘按下 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你按下了\u0026#34;); BYTE keyState[256]; //存放整数的大小 wchar_t buffer[2]; //宽字节变量 buffer[1] = \u0026#39;\\0\u0026#39;; //设置终止符 if (GetKeyboardState(keyState)) //获取按键状态 返回布尔 keyState其中的265键 {\t//判断返回是不是大于0 //ToUnicode 将指定的虚拟键代码和键盘状态转换为相应的 Unicode 字符。 ToUnicode 参数 1. 要转换的虚拟密钥代码。 2. 要转换的密钥的硬件 扫描代码 。 3. keyState 前键盘状态的 256 字节数组的指针。 数组中 (字节) 的每个元素都包含一个键的状态。 4. 已接收的按键 5，接收按键的缓冲区大小 6，函数行为 ‘0’ 不受理ALT+数字键组合 if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) { wcout \u0026lt;\u0026lt; \u0026#34;按下:\u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; // wcout宽字节输出 if (97 == buffer[0]) //判断符合条件退出 { PostQuitMessage(0); } } } } else if(wParam == WM_KEYUP) //键盘松开 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你松开了\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;键盘处于按下与松开的叠加状态？？？？\u0026#34;); } } } int main() { //安装HOOK HHOOK hKeyHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookCallback, NULL, 0); //判断是否HOOK成功 if (hKeyHook == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;获取失败\u0026#34;); } //消息循环 //GetMessage 调用线程的 消息队列 里取得一个消息并将其放于指定的结构 MSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { //将虚拟密钥消息转换为字符消息 , 人话:把键盘的输入流转换为字符串 TranslateMessage(\u0026amp;msg); //DispatchMessageW把消息发往窗口 DispatchMessageW(\u0026amp;msg); } //卸载HOOK UnhookWindowsHookEx(hKeyHook); return 0; } 3. 逆向HOOK 源码\n//安装HOOK HHOOK hKeyHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookCallback, NULL, 0); //判断是否HOOK成功 if (hKeyHook == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;获取失败\u0026#34;); } 逆向\n.text:00414E10 push ebp ; Main函数 .text:00414E11 mov ebp, esp .text:00414E13 sub esp, 0F4h ; 申请栈空间 .text:00414E19 push ebx ; 保存栈指指针装状态 .text:00414E1A push esi .text:00414E1B push edi .text:00414E1C lea edi, [ebp+var_34] .text:00414E1F mov ecx, 0Dh .text:00414E24 mov eax, 0CCCCCCCCh .text:00414E29 rep stosd .text:00414E2B mov eax, ___security_cookie .text:00414E30 xor eax, ebp .text:00414E32 mov [ebp+var_4], eax .text:00414E35 mov esi, esp .text:00414E37 push 0 ; dwThreadId .text:00414E39 push 0 ; hmod .text:00414E3B push offset fn ; lpfn 回调函数 指向虚函数表 .text:00414E40 push 0Dh ; idHook .text:00414E42 call ds:SetWindowsHookExW .text:00414E48 cmp esi, esp .text:00414E4A call j___RTC_CheckEsp ; 检查溢出 .text:00414E4F mov [ebp+hhk], eax ; SetWindowsHook返回值 .text:00414E52 cmp [ebp+hhk], 0 ; if 返回值是否是0 .text:00414E56 jnz short loc_414E6A .text:00414E58 push offset unk_41DCC4 ; char .text:00414E5D push offset aS ; \u0026#34;%s\\n\u0026#34; .text:00414E62 call printf .text:00414E67 add esp, 8 ; 堆栈平衡 回调函数是什么时候被调用的，在debug 中查看 在调用SetWIndowsHook中传入了push Hook技术.0041119A,跟如 查看SetWindowsHook Call中\n00414E37 6A 00 push 0x0 00414E39 6A 00 push 0x0 00414E3B 68 9A114100 push Hook技术.0041119A ; 回调函数 00414E40 6A 0D push 0xD 00414E42 FF15 5C114200 call dword ptr ds:[\u0026lt;\u0026amp;USER32.SetWindowsHookExW\u0026gt;] ; apphelp.6E2B1AC0 00414E48 3BF4 cmp esi,esp 00414E4A E8 EFC4FFFF call Hook技术.0041133E 进入SetWindowsHook Call查看内部执行流程 走到基址6E2B1ADC的时候回调函数又入栈了，如何调用？\nEPB的值加上0xC的时候就是0019 FDD8 然后再取ss取值就是0041119A在调用SetWindowsHook之前存放回调函数的位置，然后压入Call中这是产生关联不会执行。\n要是说回调函数被那个函数调用了只能说：回调函数是由操作系统在特定事件发生时主动调用的，而不是由用户代码直接调用的。是在GetMessage之后被调用的\nMSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { //将虚拟密钥消息转换为字符消息 , 人话:把键盘的输入流转换为字符串 TranslateMessage(\u0026amp;msg); //DispatchMessageW把消息发往窗口 DispatchMessageW(\u0026amp;msg); } //卸载HOOK UnhookWindowsHookEx(hKeyHook); return 0; .text:00414E6A mov esi, esp .text:00414E6C push 0 ; wMsgFilterMax 四个参数 .text:00414E6E push 0 ; wMsgFilterMin .text:00414E70 push 0 ; hWnd .text:00414E72 lea eax, [ebp+Msg] ; 取内存地址 .text:00414E75 push eax ; lpMsg 压入指针 .text:00414E76 call ds:GetMessageW ; 四个参数压入GetMessagW .text:00414E7C cmp esi, esp ; 检查溢出 .text:00414E7E call j___RTC_CheckEsp .text:00414E83 test eax, eax ; 条件永远为真 .text:00414E85 jz short loc_414EAF ; ZF为1跳转 .text:00414E87 mov esi, esp ; 保存栈指针 .text:00414E89 lea eax, [ebp+Msg] .text:00414E8C push eax ; lpMsg .text:00414E8D call ds:TranslateMessage .text:00414E93 cmp esi, esp ; 检查溢出 .text:00414E95 call j___RTC_CheckEsp .text:00414E9A mov esi, esp .text:00414E9C lea eax, [ebp+Msg] .text:00414E9F push eax ; lpMsg .text:00414EA0 call ds:DispatchMessageW .text:00414EA6 cmp esi, esp .text:00414EA8 call j___RTC_CheckEsp .text:00414EAD jmp short loc_414E6A ; 这是一个while(True) 循环因为 只有 00414E85 能跳出 jmp 但是永远为真True .text:00414EAF ; --------------------------------------------------------------------------- .text:00414EAF .text:00414EAF loc_414EAF: ; CODE XREF: _main_0+75↑j .text:00414EAF mov esi, esp .text:00414EB1 mov eax, [ebp+hhk] .text:00414EB4 push eax ; hhk 压入SetWindowsHook 的句柄 .text:00414EB5 call ds:UnhookWindowsHookEx ; 退出Hook函数 KeyboardHookCallback (回调函数)\nLRESULT CALLBACK KeyboardHookCallback(int nCode, WPARAM wParam, LPARAM lParam) {\tif (nCode \u0026gt;= 0) { KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; //获取按下的键的虚拟键码、扫描码、扩展键标志等。 if (wParam == WM_KEYDOWN) //键盘按下3 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你按下了\u0026#34;); BYTE keyState[256]; //存放整数的大小 wchar_t buffer[2]; //宽字节变量 2 给字节 buffer[1] = \u0026#39;\\0\u0026#39;; //设置终止符 if (GetKeyboardState(keyState)) //获取按键状态 返回布尔 keyState其中的265键 .text:004147D3 xor eax, ebp .text:004147D5 mov [ebp+var_4], eax ; if (nCode \u0026gt;= 0) .text:004147D8 cmp [ebp+arg_0], 0 .text:004147DC jl loc_414912 ; 回调函数结束（KeyboardHookCallback） .text:004147E2 mov eax, [ebp+arg_8] ; KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; .text:004147E5 mov [ebp+var_C], eax .text:004147E8 cmp [ebp+arg_4], 100h ; if (wParam == WM_KEYDOWN(0x100)) //键盘按下 .text:004147EF jnz loc_4148E3 .text:004147F5 push offset unk_41DC74 ; char 字符串：你按下了 .text:004147FA push offset aS ; \u0026#34;%s\\n\u0026#34; .text:004147FF call printf .text:00414804 add esp, 8 ; printf堆栈平衡 .text:00414807 mov [ebp+var_1EC], 2 .text:00414811 cmp [ebp+var_1EC], 4 .text:00414818 jnb short loc_41481C ; 检查堆栈溢出的Call .text:0041481A jmp short loc_414821 .text:0041481C ; --------------------------------------------------------------------------- .text:0041481C .text:0041481C loc_41481C: ; CODE XREF: sub_4147B0+68↑j .text:0041481C call j____report_rangecheckfailure ; 检查堆栈溢出的Call .text:00414821 .text:00414821 loc_414821: ; CODE XREF: sub_4147B0+6A↑j .text:00414821 xor eax, eax .text:00414823 mov ecx, [ebp+var_1EC] ; wchar_t buffer[2]; .text:00414829 mov [ebp+ecx+pwszBuff], ax ; buffer[1] = \u0026#39;\\0\u0026#39;; .text:00414831 mov esi, esp .text:00414833 lea eax, [ebp+KeyState] ; BYTE keyState[256]; .text:00414839 push eax ; lpKeyState .text:0041483A call ds:GetKeyboardState ; if (GetKeyboardState(keyState)) if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) { wcout \u0026lt;\u0026lt; \u0026#34;按下:\u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; // wcout宽字节输出 .text:0041487D test eax, eax ; if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) .text:0041487F jle short loc_4148E1 ; 跳到函数结束 .text:00414881 mov esi, esp .text:00414883 push offset sub_411505 .text:00414888 lea eax, [ebp+pwszBuff] .text:0041488E push eax ; String buffer .text:0041488F push offset Str ; Str \u0026#34;按下\u0026#34; .text:00414894 mov ecx, ds:?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wostream std::wcout .text:0041489A push ecx ; int .text:0041489B call sub_4111D6 ; cout \u0026lt;\u0026lt; \u0026#34;按下：\u0026#34; \u0026lt;\u0026lt; endl; .text:004148A0 add esp, 8 .text:004148A3 push eax ; int .text:004148A4 call sub_4112E4 ; wcout \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl .text:004148A9 add esp, 8 .text:004148AC mov ecx, eax .text:004148AE call ds:??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; 我也不清楚这是什么 if (97 == buffer[0]) //判断符合条件退出 { PostQuitMessage(0); } .text:004148C0 imul ecx, eax, 0 .text:004148C3 movzx edx, [ebp+ecx+pwszBuff] .text:004148CB cmp edx, 61h ; \u0026#39;a\u0026#39; ; if (97 == buffer[0]) .text:004148CE jnz short loc_4148E1 .text:004148D0 mov esi, esp .text:004148D2 push 0 ; nExitCode .text:004148D4 call ds:PostQuitMessage ; 退出消息队列 if(wParam == WM_KEYUP) //键盘松开 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你松开了\u0026#34;); } .text:004148E3 .text:004148E3 loc_4148E3: ; CODE XREF: sub_4147B0+3F↑j .text:004148E3 cmp [ebp+arg_4], 101h ; else if(wParam == WM_KEYUP) //键盘松开 .text:004148EA jnz short loc_414900 .text:004148EC push offset unk_41DC8C ; 字符串：你松开了 .text:004148F1 push offset aS ; \u0026#34;%s\\n\u0026#34; .text:004148F6 call printf .text:004148FB add esp, 8 .text:004148FE jmp short loc_414912 ; 回调函数结束（KeyboardHookCallback） 知识星球 ","permalink":"http://guozhi1.github.io/posts/tech/hook%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E9%80%86%E5%90%91/","summary":"一、WidnowsHOOK分类 系统钩子（System Hooks）：系统钩子是最常见的一类钩子，用于监视和修改系统级别的事件。系统钩子可以捕获和处理各种系统事件，如键盘输入、鼠标消息、窗口消息等。系统钩子可以全局范围内生效，可以对整个系统中的事件进行拦截和处理。 应用程序钩子（App","title":"键盘HOOK学习以及逆向"},{"content":" 可以正常使用的功能点截取数据包，删除cookie看对业务是否能正常处理，如果处理就是未授权。\n可以f12查看前端页面是否存在未授权的API接口\n修改返回包\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%8C%96%E6%8E%98/","summary":"可以正常使用的功能点截取数据包，删除cookie看对业务是否能正常处理，如果处理就是未授权。 可以f12查看前端页面是否存在未授权的API接口 修改返回包","title":"Src未授权访问挖掘"},{"content":"OAsys代码审计 知识来源\n1. sql注入 全局搜索可以注入的地方${可以找到sql注入的地方。#{}是预编译不可以进行注入的。 做了一个简单的判断然后进行拼接操作。 这个语句的id是sortMyNotice（我没截进去） 然后在这个所属的类 在cn.gson.oasys.mappers这个包下的.NoticeMapper类 可以看到是 这就可以看到传入了baseKey 这个参数 然后找到哪里实例化了它\n@RequestMapping(\u0026#34;informlistpaging\u0026#34;) /*GET POST都可以*/ public String informListPaging(@RequestParam(value = \u0026#34;pageNum\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) int page, /*pageNum 默认值是1 */ @RequestParam(value = \u0026#34;baseKey\u0026#34;, required = false) String baseKey, /*required = false可以没有这个参数*/ @RequestParam(value=\u0026#34;type\u0026#34;,required=false) Integer type, @RequestParam(value=\u0026#34;status\u0026#34;,required=false) Integer status, @RequestParam(value=\u0026#34;time\u0026#34;,required=false) Integer time, @RequestParam(value=\u0026#34;icon\u0026#34;,required=false) String icon, @SessionAttribute(\u0026#34;userId\u0026#34;) Long userId, Model model,HttpServletRequest req){ System.out.println(\u0026#34;baseKey:\u0026#34;+baseKey); System.out.println(\u0026#34;page:\u0026#34;+page); setSomething(baseKey, type, status, time, icon, model); PageHelper.startPage(page, 10); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list=nm.sortMyNotice(userId, baseKey, type, status, time); /*这里就调用了sql语句并且传入baseKey参数， nm是NoticeMapper 做了组合 */ PageInfo\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; pageinfo=new PageInfo\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;(list); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list2=informRelationService.setList(list); for (Map\u0026lt;String, Object\u0026gt; map : list2) { System.out.println(map); } 漏洞路径：http://127.0.0.1/informlistpaging?baseKey=sqlexp\n复现 2. 存储xss (过于冗长不推荐阅读) 我在挖掘xss时候，不会FreeMarker语法所以选择存储xss进行挖掘。 首先要关注数据库，因为因为存储xss数据都会存放在数据中 可以全局搜索save。 这个可以看name文件可控，但是路径是从数据库获取不可控。 下面的重命名文件夹也会有存储xss漏洞（我没测，一眼定真）\nonlyname方法看看有没有过滤\npublic String onlyname(String name,FilePath filepath,String shuffix,int num,boolean isfile){ Object f = null; if (isfile) { f = fldao.findByFileNameAndFpath(name, filepath); //传入路径、文件名返回对象 }else{ f = fpdao.findByPathNameAndParentId(name, filepath.getId()/*路径ID*/); } /*findByFileNameAndFpath来生成查询语句如果查询到了，就代表存在有个文件然后这段代码就解决文件名冲突问题*/ if(f != null){ int num2 = num -1; if(shuffix == null){ name = name.replace(\u0026#34;(\u0026#34;+num2+\u0026#34;)\u0026#34;, \u0026#34;\u0026#34;)+\u0026#34;(\u0026#34;+num+\u0026#34;)\u0026#34;; }else{ name = name.replace(\u0026#34;.\u0026#34;+shuffix,\u0026#34;\u0026#34;).replace(\u0026#34;(\u0026#34;+num2+\u0026#34;)\u0026#34;, \u0026#34;\u0026#34;)+\u0026#34;(\u0026#34;+num+\u0026#34;)\u0026#34;+\u0026#34;.\u0026#34;+shuffix; } num += 1; return onlyname(name,filepath,shuffix,num,isfile); } return name; /*然后就返回name了没做过滤操作*/ } 之后查看findByFileNameAndFpath这是调用了那个表都使用了什么字段。 一个文件名一个路径 return name之后看上一级\nFileList fl = fldao.findOne(renamefp); //findOne 查询对应的ID String newname = onlyname(name/*文件名我可以控制的参数*/, fl.getFpath()/*传入路径*/, fl.getFileShuffix()/*文件后缀名*/, 1, isfile/*我可以控制的参数*/); fl.setFileName(newname); //设置文件名 fldao.save(fl); //保存到表里 然后看看哪里调用的rename这个方法 然后找到调用这个路径的ftl文件 之后在这个文件找关键字然后找到页面，我不会看FreeMarker回不回显全看天意\n复现 3. xss反射 4. 任意文件读取 我感觉任意文件读取算好挖的了，比sql注入还简单。\n首先全局搜索找到可以读取文件的地方，主要是这俩函数File()进行拼接FileInputStream()进行读取操作 show/**中的**是允许多层级的，然后使用replace函数进行了过滤操作，使用了File()和FileInputStream()进行拼接读取路径\n复现 可以直接读取maven工程配置文件， 现在网站在D: 盘怎么读取C盘内容？\nhttp://192.168.0.115:8088/show//show..//show../pom.xml 6.越权 越权属于逻辑漏洞，并没有什么特别的函数可以帮助你快速找到漏洞点，相比之下黑盒可能更快出越权漏洞。 代码上主要看有没有做权限校验的逻辑功能。 像这个方法particular 这是查询报销记录的只能财务和管理员能查看，但是这个没做权限校验逻辑导致只要知道接口就可以 调用。 调用数据库了但是没做权限的验证，这就会产生越权漏洞。 只需要便利这两个参数就可以了。 id 是申请人的ID ，typename是报销的类型\n复现 使用第权限账号访问接口提交参数就好了 7.越权删除 这个查询到存在的ID就可以进行删除，也是没做权限验证。 复现 payload\nhttp://127.0.0.1:8088/dayremove?rcid=10 知识星球 ","permalink":"http://guozhi1.github.io/posts/tech/oasys%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","summary":"OAsys代码审计 知识来源 1. sql注入 全局搜索可以注入的地方${可以找到sql注入的地方。#{}是预编译不可以进行注入的。 做了一个简单的判断然后进行拼接操作。 这个语句的id是sortMyNotice（我没截进去） 然后在这个所属的类 在cn.gson.oasys.mappers这个包","title":"Oasys代码审计"},{"content":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源\n这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作\n\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过后端的但是过滤器没有进行拦截。\n1.1 xss漏洞 在找xss漏洞的时候可以先查看回显处 找到了键与值 全局搜索这个键 找到了方法名和变量名 再看看这变量做了什么 关联了键与值的关系然后发送到billlist.jsp现在就找query这个方法的所属类然后请求这个模块就行了 在全局搜索下这个请求的方法 首先需要是GET，参数是method值是query 可以先构造payload了\n请求方式+路径+方法名+值+键+payload GET /网站根目录/jsp/bill.do?method=query\u0026amp;queryProductName=\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 1.3 存储xss漏洞 先找到回显位置 再找到这个方法 可以看到提交，方式方法 在初始化了Bill()，并且把billcode设置成bill()私有的成员变量，而且是String类型可以输入数据 然后就是初始化数据库class然后添加数据。 BillServiceImpl()调用了dao层的BillDaoImpl()。启用了预编译的功能，现在需要确保这个smbms_bill表的billcode输入的不是int类型数据就可以进行xss注入了 输入的字符类型,但是只能输入长度是20的payload 漏洞复现 危害没多大就写出来图一乐吧。 因为payload长度的变化如果直接闭合标签的话就会长度不够导致失败，所以要找新的可以触发html事件的xss位置，全局搜索找到\u0026lt;a标签\u0026gt;。 触发事件可以节省payload 然后寻找提交方。显然GET\\POST都行，反正都会调用doGET()。我建议使用网页提交因为参数很多，而且有缺少的参数就会报错。\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getParameter(\u0026#34;method\u0026#34;); if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;query\u0026#34;)){ this.query(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;add\u0026#34;)){ this.add(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;view\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billview.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modify\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billmodify.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modifysave\u0026#34;)){ this.modify(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;delbill\u0026#34;)){ this.delBill(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;getproviderlist\u0026#34;)){ this.getProviderlist(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } \u0026#34;\u0026#34;+onclick=alert(1)\u0026gt; 2、密码重置漏洞 分析下修改密码的方法 注意三个点，第一是通过session来判断用户的，第二数据包里收一个值newpassword，第三newpassword不为空就可以影响flag的判断并影响最结果。 显然如果是修改自己的密码就太鸡肋了，可以看到数据包没有token，我们可以使用csrf提升危害。 知识星球 ","permalink":"http://guozhi1.github.io/posts/tech/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1smbms/","summary":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源 这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作 \u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过","title":"Java代码审计smbms"},{"content":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数\n前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http://test.com 我们可以尝试https://guozhi1.github.io/login?url=javascript:alert(1) 如果失败了，就观察与正常的url有什么不同是不是需要test.com关键字 可以尝试这个https://guozhi1.github.io/login?url=javascript://test.com/%0aalert(1) 如果不能跳转就看他和正常的url有什么不同 ","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-xss%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数 前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http:/","title":"Src挖掘 Xss漏洞"},{"content":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方\n有的轰炸只有前端限制，可以通过burp抓包进行重发测试\n有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包\n并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可以造成轰炸\n还有通过token时间戳进行校验的方式我们可以截取获取token的数据包获取token，给第二个数据包完成token校验这种是属于token重发服务器没做后端限时\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-%E7%9F%AD%E4%BF%A1%E9%82%AE%E7%AE%B1%E8%BD%B0%E7%82%B8/","summary":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方 有的轰炸只有前端限制，可以通过burp抓包进行重发测试 有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包 并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可","title":"Src挖掘 短信邮箱轰炸"},{"content":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法\nburp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者请求自己的vps查看vps日志\n之后就可以对内网进行探索。\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-pdf%E5%AF%BC%E5%87%BA%E5%AF%BC%E8%87%B4%E7%9A%84ssrf%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法 burp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者","title":"Src挖掘 Pdf导出导致的ssrf漏洞"},{"content":"前言 知识来源：《加密与解密》\n第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数\n（选择WinMain,交叉引用就可以找到上一级）\n第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调用与返回。 call可以直接跳到被调用函数的地址段。call与跳转指令有着分别不同的是，call保存返回的地址到栈中，当执行到ret的时候ret就会使用call保存在栈里的地址。 call用于函数的开始，ret用于函数的结束（不是所有ret都代表这函数的结束）。 int Add(int x,int y); main( ) { int a=5,b=6; Add(a,b); return 0; } Add(int x,int y) { return(x+y); } int Add(int x, int y); void main() { 003517A0 push ebp 003517A1 mov ebp,esp 003517A3 sub esp,0D8h 003517A9 push ebx 003517AA push esi 003517AB push edi 003517AC lea edi,[ebp-18h] 003517AF mov ecx,6 003517B4 mov eax,0CCCCCCCCh 003517B9 rep stos dword ptr es:[edi] 003517BB mov ecx,offset _99047FA2_源@cpp (035C000h) 003517C0 call @__CheckForDebuggerJustMyCode@4 (035130Ch) int a = 5, b = 6; 003517C5 mov dword ptr [a],5 003517CC mov dword ptr [b],6 Add(a,b); 003517D3 mov eax,dword ptr [b] 003517D6 push eax 003517D7 mov ecx,dword ptr [a] 003517DA push ecx 003517DB call Add (03511B3h) //函数的开始 003517E0 add esp,8 } int Add(int x, int y) { 00351740 push ebp 00351741 mov ebp,esp 00351743 sub esp,0C0h 00351749 push ebx 0035174A push esi 0035174B push edi 0035174C mov edi,ebp 0035174E xor ecx,ecx 00351750 mov eax,0CCCCCCCCh 00351755 rep stos dword ptr es:[edi] 00351757 mov ecx,offset _99047FA2_源@cpp (035C000h) 0035175C call @__CheckForDebuggerJustMyCode@4 (035130Ch) return (x + y); 00351761 mov eax,dword ptr [x] 00351764 add eax,dword ptr [y] } 00351767 pop edi 00351768 pop esi 00351769 pop ebx 0035176A add esp,0C0h 00351770 cmp ebp,esp 00351772 call __RTC_CheckEsp (0351235h) 00351777 mov esp,ebp 00351779 pop ebp 0035177A ret //函数的结束 2. 函数的参数 函数传参的三种方式，栈方式，寄存器方式，全局变量 利用栈方式\n栈的基础知识\n常用的调用约定 利用寄存器传参 Fastcall特点就快（因为寄存器传参的原因）\n不同编译器的Fastcall也是不一样的 Visual C++,函数参数左边2个不大于4字节（DWORD）参数放在eax，edx寄存器， 寄存器用完用栈，从从右到左压栈，子程序处理堆栈平衡。浮点值，远指针，_int64 总是栈来传递 Borland Delphi/C++ 的 Fastcall 左边3个不大于4字节（DWORD），分别放在eax，edx，ecx寄存器中其余参数按照PASCAL方式压入。 3. 函数的返回值 return返回值 一般情况下函数的返回值会放在eax中，如果处理的大小超过eax寄存器的容量，edx寄存器中。 通过参数按传引方式返回值\n传递两种方式分别是，传值，引用 - 传值，引用\n示例代码 #include \u0026lt;stdio.h\u0026gt; void max(int *a, int *b); void main() { int a = 5; int b = 6; max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 printf(\u0026#34;a,b中较大的数是：%d\u0026#34;,a); } void max(int *a, int *b) {\t//if 不带{} 就会影响下一行缩进的代码，如果下列多行代码缩进只会影响if下一行的代码，剩下的无条件执行 if (*a \u0026lt; *b) //*a 代表间接变量去到\u0026amp;a的内存地址 *a 就是取到这个内存地址为保存的的值,然后今进行比较 *a = *b; // 把*b的值赋值到*a位置 } 00B818D5 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B818DA call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) int a = 5; 00B818DF mov dword ptr [a],5 //a赋值 int b = 6; 00B818E6 mov dword ptr [b],6 //b赋值 max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 00B818ED lea eax,[b] //第二个参数 lea取的是地址 00B818F0 push eax 00B818F1 lea ecx,[a] //第一个参数 lea取的是地址 00B818F4 push ecx 00B818F5 call max (0B81280h) //调用 max 子程序 00B818FA add esp,8 （_cdecl） max()\n00B81787 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B8178C call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) if (*a \u0026lt; *b) 00B81791 mov eax,dword ptr [a] //获取a在内存中的十六进制 00B81794 mov ecx,dword ptr [b] //获取b在内存中的十六进制 00B81797 mov edx,dword ptr [eax] //edx = eax 00B81799 cmp edx,dword ptr [ecx] //判断 *a\u0026lt;*b 是否满足条件 00B8179B jge __$EncStackInitStart+2Bh (0B817A7h) //大于等于跳转 *a = *b; 00B8179D mov eax,dword ptr [a] //a 00B817A0 mov ecx,dword ptr [b] //b 00B817A3 mov edx,dword ptr [ecx] // edx=b 00B817A5 mov dword ptr [eax],edx // a = b 赋值 并且作为返回值 } 00B817A7 pop edi //跳到这什么都不改 00B817A8 pop esi 00B817A9 pop ebx 00B817AA add esp,0C0h 00B817B0 cmp ebp,esp 00B817B2 call __RTC_CheckEsp (0B8123Fh) 00B817B7 mov esp,ebp 00B817B9 pop ebp 00B817BA ret 第三章数据结构 1.局部函数 利用栈存放局部变量\n程序sub esp,8这句话就是为局部变量分配分配内存空间，用[ebp-xxxx]寻址调用这些变量，而参数调用相对于ebp偏移量正的，即[ebp+xxxx]。编译在优化模式下。 当函数退出时，用add esp, 8指令平衡栈，以释放局部变量占用的内存，有的编译器给esp 添加负值进行内存的分配，编译器也有可能会用push reg代替sub esp,4。 局部变量分配与清除栈的方式 形式一 形式二 形式三 add esp,n\n\u0026hellip;.\nsub esp,n add esp,-n\n\u0026hellip;.\nsub esp,-n push reg\n\u0026hellip;\npop reg 利用寄存器存放局部变量 int add(int x,int y); int main(void) { int a=5,b=6; add(a,b); return 0; } int add(int x,int y) { int z; z=x+y; return(z); } .text:004117B0 push ebp .text:004117B1 mov ebp, esp .text:004117B3 sub esp, 0D8h //局部变量申请的栈内存空间 .text:004117B9 push ebx .text:004117BA push esi .text:004117BB push edi .text:004117BC lea edi, [ebp+var_18] .text:004117BF mov ecx, 6 .text:004117C4 mov eax, 0CCCCCCCCh .text:004117C9 rep stosd .text:004117CB mov ecx, offset unk_41C000 .text:004117D0 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) .text:004117D5 mov [ebp+var_8], 5 //局部变量放入var_8中 .text:004117DC mov [ebp+var_14], 6 //局部变量放入var_14中 .text:004117E3 mov eax, [ebp+var_14] //取出var_14放入eax .text:004117E6 push eax .text:004117E7 mov ecx, [ebp+var_8] //取出var_8放入ecx .text:004117EA push ecx .text:004117EB call sub_4112AD .text:004117F0 add esp, 8 //平栈 _cdecl .text:004117F3 xor eax, eax .text:004117F5 pop edi .text:004117F6 pop esi .text:004117F7 pop ebx .text:004117F8 add esp, 0D8h //回收申请的栈内存空间 .text:004117FE cmp ebp, esp .text:00411800 call j___RTC_CheckEsp .text:00411805 mov esp, ebp .text:00411807 pop ebp .text:00411808 retn .text:00411808 _main_0 endp .text:00411808 利用寄存器存放局部变量 除了esp，ebp栈寄存器，其余6个通用寄存器尽可能的存放变量，这样可以减少代码提高程序的执行效率，逆向分析中局部变量生命周期短，必须及时确定当前寄存器的变量是那个变量 2.全局变量 全局变量通常位于.data段，程序访问全局变量时，一般会用固定的硬编码地址对内存地址进行寻址\n如果某个函数的改变了全局变量的值，就能影响其他函数，可以利用全局变量传递参数或者函数的返回值。 全局变量在程序的执行过程中占用内存单元，不像局部变量那样需要的时候才开辟存储单元。\n源码示例\nint z; int add(int x,int y); int main(void) { int a=5,b=6; z=7; add(a,b); return 0; } int add(int x,int y) { return(x+y+z); } main\npush ebp mov ebp, esp sub esp, 0D8h //局部变量申请空间 ....... mov ecx, 6 mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov [ebp+var_8], 5 //局部变量 mov [ebp+var_14], 6 //局部变量 mov dword_41A138, 7 //全局变量 mov eax, [ebp+var_14] push eax ...... retn add()\npush ebp mov ebp, esp sub esp, 0C0h ...... mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov eax, [ebp+arg_0] add eax, [ebp+arg_4] add eax, dword_41A138 //全局变量 pop edi ...... call j___RTC_CheckEsp mov esp, ebp pop ebp retn charGPT回答\n可以通过查看汇编代码中的内存地址来判断变量是局部变量还是全局变量。在汇编中，局部变量通常存储在堆栈中，而全局变量则存储在数据段中。通过查看变量的内存地址，如果它在堆栈范围内，则是局部变量，否则是全局变量。\n3.数组 数组在内存中是连续存放的，在汇编访问状态下访问数组一般是通过基址加变址寻址的方式实现的。\n#include \u0026lt;stdio.h\u0026gt; int main(void) { static int a[3]={0x11,0x22,0x33}; int i,s=0,b[3]; for(i=0;i\u0026lt;3;i++) { s=s+a[i]; b[i]=s; } for(i=0;i\u0026lt;3;i++) { printf(\u0026#34;%d\\n\u0026#34;,b[i]); } return 0; } .text:00401009 mov edi, dword_407030[eax] ; ;dword_407030是数组的空间位置, eax 现在是0 指向第一个元素 .text:0040100F add eax, 4 ; eax = 4 这是偏移下一次的地址指向了dword_407034 .text:00401012 add ecx, edi ; ;ecx = dword_407030 数组列表 .text:00401014 cmp eax, 0Ch ; ;if eax == 12 .text:00401017 mov [esp+eax+14h+var_10], ecx ; [esp+eax+14h+var_10] = dword_407030 .text:0040101B jl short loc_401009 ; 等于12的时候就不跳转了 .text:0040101D lea esi, [esp+14h+var_C] ; 数组列表现在到esi中了 .text:00401021 mov edi, 3 ; edi = 3 覆盖了数组元素 .text:00401026 .text:00401026 loc_401026: ; CODE XREF: _main+3A↓j .text:00401026 mov eax, [esi] ; 第二个循环 .text:00401028 push eax .text:00401029 push offset aD ; \u0026#34;%d\u0026#34; .text:0040102E call printf ; 打印一次 .text:00401033 add esp, 8 ; 栈平衡 .text:00401036 add esi, 4 ; 数组指向下一个元素 .text:00401039 dec edi ; edi = 3-1计数器 .text:0040103A jnz short loc_401026 ; 第二个循环 .text:0040103C pop edi .text:0040103D xor eax, eax .text:0040103F pop esi .text:00401040 add esp, 0Ch .text:00401043 retn .text:00401043 _main endp dword_407030\n.data:0040702C align 10h ;[0]第一个元素 .data:00407030 dword_407030 dd 11h ; DATA XREF: _main:loc_401009↑r .data:00407034 db 22h ; \u0026#34; .data:00407035 db 0 .data:00407036 db 0 .data:00407037 db 0 .data:00407038 db 33h ;最后指向的元素 .data:00407039 db 0 .data:0040703A db 0 .data:0040703B db 0 .data:0040703C aD db \u0026#39;%d\u0026#39; ; DATA XREF: _main+29↑o .data:0040703E db 0Ah .data:0040703F db 0 第四章虚函数 虚函数是在程序运行之前定义的函数，虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有的虚函数引用通常放在一个专用的数组————虚函数表，数组中的每个元素存放的就是类中的虚函数地址。\n调用虚函数时，程序先从虚函数表指针，得到函数地址，再根据取出的函数地址调用函数 对象实例 \u0026ndash;\u0026gt; 函数表 \u0026ndash;\u0026gt; 要调用的函数的地址 #include \u0026lt;stdio.h\u0026gt; class CSum { public: virtual int Add(int a, int b) { return (a + b); } virtual\tint\tSub(int a, int b ) { return (a - b); } }; void main() { CSum*\tpCSum = new CSum ; pCSum-\u0026gt;Add(1,2); pCSum-\u0026gt;Sub(1,2); } .text:00401000 push esi .text:00401001 push 4 ; Size .text:00401003 call ??2@YAPAXI@Z ; new()函数，这里决定了虚表的位置 .text:00401008 add esp, 4 .text:0040100B test eax, eax .text:0040100D jz short loc_401019 .text:0040100F mov dword ptr [eax], offset off_4050A0 ; 这是指向虚表的的指针，eax的地址存放的内容是004050A0 .text:00401015 mov esi, eax ; esi=eax的内存地址 .text:00401017 jmp short loc_40101B ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:00401019 ; --------------------------------------------------------------------------- .text:00401019 .text:00401019 loc_401019: ; CODE XREF: _main+D↑j .text:00401019 xor esi, esi .text:0040101B .text:0040101B loc_40101B: ; CODE XREF: _main+17↑j .text:0040101B mov eax, [esi] ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:0040101D push 2 .text:0040101F push 1 .text:00401021 mov ecx, esi ; ecx = esi = eax的内存地址 .text:00401023 call dword ptr [eax] ; 第一次调用函数 .text:00401025 mov edx, [esi] ; edx = 004050A0 .text:00401027 push 2 .text:00401029 push 1 .text:0040102B mov ecx, esi .text:0040102D call dword ptr [edx+4] ; 因为在内存中是连续的，所以第二次调用+4的偏移。004050A4 = 4 + (edx = 004050A0) .text:00401030 pop esi .text:00401031 retn .text:00401031 _main endp 现在可以看看004050A0这位置存放的是什么\n.rdata:004050A0 off_4050A0 dd offset sub_401040 ; DATA XREF: _main+F↑o //add函数 .rdata:004050A4 dd offset sub_401050 //sub函数 004050A0、004050A4就是不同函数的地址\n第五章控制流程语句 1. if判断 2. switch #include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 10:printf(\u0026#34;a=10\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } .text:0040100A push offset Format ; \u0026#34;%d\u0026#34; .text:0040100F call _scanf ; scanf .text:00401014 add esp, 8 ; 堆栈平衡 .text:00401017 mov ecx, [ebp+var_4] .text:0040101A mov [ebp+var_8], ecx ; switch(a) .text:0040101D cmp [ebp+var_8], 1 ; case 1: .text:00401021 jz short loc_401031 ; print .text:00401023 cmp [ebp+var_8], 2 ; case 2: .text:00401027 jz short loc_401040 .text:00401029 cmp [ebp+var_8], 0Ah ; case 10: .text:0040102D jz short loc_40104F .text:0040102F jmp short loc_40105E 优化后的\n.text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov eax, [esp+0Ch+var_4] .text:00401014 add esp, 8 .text:00401017 dec eax .text:00401018 jz short loc_401055 .text:0040101A dec eax .text:0040101B jz short loc_401044 .text:0040101D sub eax, 8 .text:00401020 jz short loc_401033 .text:00401022 push offset aADefault ; \u0026#34;a=default\u0026#34; .text:00401027 call sub_401070 .text:0040102C add esp, 4 .text:0040102F xor eax, eax 最大的区别就是原先使用的时内存寻址现在使用的是寄存器，调用寄存器确实比寻址快，就是寄存器少。\n2.2 switch跳转表 这个switch逆向有点东西，这个因为case多会生成switch跳转表再由跳转表进行跳转\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 3:printf(\u0026#34;a=3\u0026#34;); break; case 4:printf(\u0026#34;a=4\u0026#34;); break; case 5:printf(\u0026#34;a=5\u0026#34;); break; case 6:printf(\u0026#34;a=6\u0026#34;); break; case 7:printf(\u0026#34;a=7\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } 假如我们输入的的是7\n.text:00401000 push ecx .text:00401001 lea eax, [esp+4+var_4] .text:00401005 push eax .text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov ecx, [esp+0Ch+var_4] ; ecx是存放的是从缓冲区读取的内容 .text:00401014 add esp, 8 .text:00401017 lea eax, [ecx-1] ; switch 7 cases .text:0040101A cmp eax, 6 ; 判断eax是否在六case之内。大于6进行ja跳转就是default分支 .text:0040101D ja short def_40101F ; jumptable 0040101F default case .text:0040101F jmp ds:jpt_40101F[eax*4] ; switch jump 要在4010B0的地址偏移量（eax * 4 =要跳转的分支） 走到00401017就会变成6，然后到0040101A进行比较相等不会触发ja跳转， 到0040101F的时候就是(eax=6)*4 = 24然后转换成16进制得到的偏移量就是18 得到的地址就是0040108C\n.text:0040108C .text:0040108C loc_40108C: ; CODE XREF: _main+1F↑j .text:0040108C ; DATA XREF: .text:jpt_40101F↓o .text:0040108C push offset aA7 ; jumptable 0040101F case 7 这是字符串 .text:00401091 call printf .text:00401096 add esp, 4 .text:00401099 xor eax, eax .text:0040109B pop ecx .text:0040109C retn 转移指令机器码计算（跳过） 条件设置指令 （跳过） 第六章循环语句 for循环\n第七章数学运算符 1. 加法 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; printf(\u0026#34;%d\u0026#34;,a+b+0x78); return 0; } lea 是一条纯计算指令\n.text:00401000 push ecx .text:00401001 mov eax, [esp+4+var_4] ; int a .text:00401005 mov ecx, [esp+4+var_4] ; int b .text:00401009 lea edx, [ecx+eax+78h] ; 计算a+b+0x78,结果放到edx中 .text:0040100D push edx .text:0040100E push offset aD ; \u0026#34;%d\u0026#34; .text:00401013 call printf 除法（这个可以看C++反汇编大揭秘书上讲的比较好） 第八章文本字符串 1. 字符串的存储格式 C字符串：也称ASCII字符串 \u0026ldquo;Z\u0026quot;表示其以\u0026rdquo;\\0\u0026quot;为结束标识符。“\\0”代表ASCII码为0的字符。ASCII为0的字符的时候显示空操作符 DOS字符串： 以$结尾作为终止符，基本已被淘汰 PASCAL字符串：这个字符串没有终止符，而是长度符号字符串的头部定义1个字节，用于指示当前字符串的长度，字符串的长度不能过255字符。 Delphi字符串： 为了解决PASCAL 255长度限制设计的增加了对长度的支持，表示长度扩展到2字节，使字符串最大长度达到65535 四字节的Delphi: 少见，表示长度扩展到4字节字符串长度可以到达4GB 字符寻址指令 mov eax,[00401000] ;直接寻址，把00401000地址的双字节数据放到eax中 mov eax, [ecx] ;间接寻址, 即把ecx中的地址所指的内容放到eax lea eax,[00401000] ;把00401000装到eax中 ","permalink":"http://guozhi1.github.io/posts/tech/32%E4%BD%8D%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF/","summary":"前言 知识来源：《加密与解密》 第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数 （选择WinMain,交叉引用就可以找到上一级） 第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调","title":"32位逆向技术"},{"content":"调用约定 知识来源\n允许使用VARARG：表示参数个数可以是不确定\n约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall\nint Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默认调用约定 Test(1,2,3,4,5); 00A71891 push 5 00A71893 push 4 00A71895 push 3 00A71897 push 2 //第二个参宿 00A71899 push 1 //第一个参宿 00A7189B call Test (0A71398h) 00A718A0 add esp,14h //平栈由调用者执行 _cdecl从右到左进行压栈操作，由调用者进行压栈操作\n_stdcall\n_stdcall 是WindowsApi默认的调用约定 Test(1,2,3,4,5); 00271891 push 5 00271893 push 4 00271895 push 3 00271897 push 2 00271899 push 1 0027189B call Test (02713ACh) //由被调用者平栈 Test_Call\nint _stdcall Test(int a,int b,int c,int d,int e) { 00F41760 push ebp 00F41761 mov ebp,esp 00F41763 sub esp,0C0h 00F41769 push ebx 00F4176A push esi 00F4176B push edi 00F4176C mov edi,ebp 00F4176E xor ecx,ecx 00F41770 mov eax,0CCCCCCCCh 00F41775 rep stos dword ptr es:[edi] 00F41777 mov ecx,offset _99047FA2_源@cpp (0F4C029h) 00F4177C call @__CheckForDebuggerJustMyCode@4 (0F4130Ch) return a + b + c + d + e; 00F41781 mov eax,dword ptr [a] 00F41784 add eax,dword ptr [b] 00F41787 add eax,dword ptr [c] 00F4178A add eax,dword ptr [d] 00F4178D add eax,dword ptr [e] } 00F41790 pop edi 00F41791 pop esi 00F41792 pop ebx 00F41793 add esp,0C0h 00F41799 cmp ebp,esp 00F4179B call __RTC_CheckEsp (0F41235h) 00F417A0 mov esp,ebp 00F417A2 pop ebp 00F417A3 ret 14h //平栈操作 _stdcall 是从右到左进行压栈，但是平栈操作由被被调用者执行\n_fastcall 008F1891 push 6 008F1893 push 5 008F1895 push 4 008F1897 push 3 008F1899 mov edx,2 008F189E mov ecx,1 008F18A3 call Test (08F13C0h) _fastcall 比较特殊他会，从左往右压入参数，但是前两个参数会被赋值到寄存器中，然后由被调者自己平栈\nint _fastcall Test(int a,int b,int c,int d,int e,int w) { 008F1760 push ebp 008F1761 mov ebp,esp 008F1763 sub esp,0D8h 008F1769 push ebx 008F176A push esi 008F176B push edi 008F176C push ecx 008F176D lea edi,[ebp-18h] 008F1770 mov ecx,6 008F1775 mov eax,0CCCCCCCCh 008F177A rep stos dword ptr es:[edi] 008F177C pop ecx 008F177D mov dword ptr [b],edx 008F1780 mov dword ptr [a],ecx 008F1783 mov ecx,offset _99047FA2_源@cpp (08FC029h) 008F1788 call @__CheckForDebuggerJustMyCode@4 (08F130Ch) return a + b + c + d + e; 008F178D mov eax,dword ptr [a] 008F1790 add eax,dword ptr [b] 008F1793 add eax,dword ptr [c] 008F1796 add eax,dword ptr [d] 008F1799 add eax,dword ptr [e] } 008F179C pop edi 008F179D pop esi 008F179E pop ebx 008F179F add esp,0D8h 008F17A5 cmp ebp,esp 008F17A7 call __RTC_CheckEsp (08F1235h) 008F17AC mov esp,ebp 008F17AE pop ebp 008F17AF ret 10h //平栈。因为我多加了个参数导致和之前长度不一样了。 x64 下的调用约定 调用规则是由编译器决定的现在这是由VS平台下的调用约定，这是一种变形的_fastcall。\nTest(1,2,3,4,5); 00007FF631FB187B mov dword ptr [rsp+20h],5 00007FF631FB1883 mov r9d,4 00007FF631FB1889 mov r8d,3 00007FF631FB188F mov edx,2 00007FF631FB1894 mov ecx,1 00007FF631FB1899 call Test (07FF631FB13ACh) 参数从右到左,前四个参数会放到寄存器中分别是,edx,ecx,r8,r9 寄存器。 寄存器的速度是高于栈传参的速度的\nint _cdecl Test(int a,int b,int c,int d,int e) { 00007FF631FB1760 mov dword ptr [rsp+20h],r9d 00007FF631FB1765 mov dword ptr [rsp+18h],r8d 00007FF631FB176A mov dword ptr [rsp+10h],edx 00007FF631FB176E mov dword ptr [rsp+8],ecx 00007FF631FB1772 push rbp 00007FF631FB1773 push rdi 00007FF631FB1774 sub rsp,0E8h 可以看到这个r9,r8,edx,ecx又放入了栈空间，这是为什么？\n寄存器中的值放入栈预留空间，是为了防止参数传递过程中，寄存器需要接收其他值而无法传递参数，或者其他值无法接收的情况。\n仔细查看会发现x64这个调用约定是没有平栈的操作的是因为\n64位下一开始系统会为main（）函数开辟一个很大的栈区，但是main（）函数并未消耗掉这么大的栈区空间，这时候怎么办呢？子函数就会还继续利用main（）函数的栈区空间，所以main（）函数并不用对子函数栈区空间进行清理。\n","permalink":"http://guozhi1.github.io/posts/tech/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","summary":"调用约定 知识来源 允许使用VARARG：表示参数个数可以是不确定 约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall int Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默","title":"逆向基础-调用约定"},{"content":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll\n安全厂商也可以通过接入Amsi进行查杀提高安全性\n接入Amsi的相关厂商\nAMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库\nASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位置 行:1 字符: 1 + amsiutils + ~~~~~~~~~ 此脚本包含恶意内容，已被你的防病毒软件阻止。 + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : ScriptContainedMaliciousContent PS C:\\Users\\32569\u0026gt; 长度清零 先对Amsi.dll的使用IDA进行逆向，查调用函数存在一个AmsiScanBuffer函数。\n扫描充满内容的缓冲区以查找恶意软件。 HRESULT AmsiScanBuffer( [in] HAMSICONTEXT amsiContext, [in] PVOID buffer, [in] ULONG length, [in] LPCWSTR contentName, [in, optional] HAMSISESSION amsiSession, [out] AMSI_RESULT *result ); 第三个参数是设置AMSi从缓冲区读取的长度，我们可以把这个设置为0让它读不到东西。\n","permalink":"http://guozhi1.github.io/posts/tech/%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%85%8D%E6%9D%80/","summary":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll 安全厂商也可以通过接入Amsi进行查杀提高安全性 接入Amsi的相关厂商 AMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库 ASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位","title":"文本类型免杀"},{"content":"","permalink":"http://guozhi1.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"http://guozhi1.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"http://guozhi1.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客(源码来源大佬)\r小白工具箱chargpt\r非常好用的工具站\r知识星球（免费）\r做网络安全知识汇总\r小白工具箱github镜像\r非常好用的工具站\r棱角安全社区\r非常好用的工具站\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"http://guozhi1.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客(源码来源大佬) 小白工具箱chargpt 非常好用的工具站 知识星球（免费） 做网络安全知识汇总 小白工具箱github镜像 非常好用的工具站 棱角安全社区 非常好用的工具站 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求","title":"🤝友链"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"http://guozhi1.github.io/about/","summary":"关于我 英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"}]