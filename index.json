[{"content":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源\n这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作\n\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过后端的但是过滤器没有进行拦截。\n1.1 xss漏洞 在找xss漏洞的时候可以先查看回显处 找到了键与值 全局搜索这个键 找到了方法名和变量名 再看看这变量做了什么 关联了键与值的关系然后发送到billlist.jsp现在就找query这个方法的所属类然后请求这个模块就行了 在全局搜索下这个请求的方法 首先需要是GET，参数是method值是query 可以先构造payload了\n请求方式+路径+方法名+值+键+payload GET /网站根目录/jsp/bill.do?method=query\u0026amp;queryProductName=\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 1.3 存储xss漏洞 先找到回显位置 再找到这个方法 可以看到提交，方式方法 在初始化了Bill()，并且把billcode设置成bill()私有的成员变量，而且是String类型可以输入数据 然后就是初始化数据库class然后添加数据。 BillServiceImpl()调用了dao层的BillDaoImpl()。启用了预编译的功能，现在需要确保这个smbms_bill表的billcode输入的不是int类型数据就可以进行xss注入了 输入的字符类型,但是只能输入长度是20的payload 漏洞复现 危害没多大就写出来图一乐吧。 因为payload长度的变化如果直接闭合标签的话就会长度不够导致失败，所以要找新的可以触发html事件的xss位置，全局搜索找到\u0026lt;a标签\u0026gt;。 触发事件可以节省payload 然后寻找提交方。显然GET\\POST都行，反正都会调用doGET()。我建议使用网页提交因为参数很多，而且有缺少的参数就会报错。\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getParameter(\u0026#34;method\u0026#34;); if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;query\u0026#34;)){ this.query(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;add\u0026#34;)){ this.add(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;view\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billview.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modify\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billmodify.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modifysave\u0026#34;)){ this.modify(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;delbill\u0026#34;)){ this.delBill(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;getproviderlist\u0026#34;)){ this.getProviderlist(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } \u0026#34;\u0026#34;+onclick=alert(1)\u0026gt; 2、密码重置漏洞 分析下修改密码的方法 注意三个点，第一是通过session来判断用户的，第二数据包里收一个值newpassword，第三newpassword不为空就可以影响flag的判断并影响最结果。 显然如果是修改自己的密码就太鸡肋了，可以看到数据包没有token，我们可以使用csrf提升危害。 guozhi 知识星球 ","permalink":"http://guozhi1.github.io/posts/tech/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1smbms/","summary":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源 这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作 \u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过","title":"Java代码审计smbms"},{"content":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数\n前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http://test.com 我们可以尝试https://guozhi1.github.io/login?url=javascript:alert(1) 如果失败了，就观察与正常的url有什么不同是不是需要test.com关键字 可以尝试这个https://guozhi1.github.io/login?url=javascript://test.com/%0aalert(1) 如果不能跳转就看他和正常的url有什么不同 ","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-xss%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数 前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http:/","title":"Src挖掘 Xss漏洞"},{"content":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方\n有的轰炸只有前端限制，可以通过burp抓包进行重发测试\n有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包\n并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可以造成轰炸\n还有通过token时间戳进行校验的方式我们可以截取获取token的数据包获取token，给第二个数据包完成token校验这种是属于token重发服务器没做后端限时\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-%E7%9F%AD%E4%BF%A1%E9%82%AE%E7%AE%B1%E8%BD%B0%E7%82%B8/","summary":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方 有的轰炸只有前端限制，可以通过burp抓包进行重发测试 有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包 并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可","title":"Src挖掘 短信邮箱轰炸"},{"content":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法\nburp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者请求自己的vps查看vps日志\n之后就可以对内网进行探索。\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-pdf%E5%AF%BC%E5%87%BA%E5%AF%BC%E8%87%B4%E7%9A%84ssrf%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法 burp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者","title":"Src挖掘 Pdf导出导致的ssrf漏洞"},{"content":"前言 知识来源：《加密与解密》\n第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数\n（选择WinMain,交叉引用就可以找到上一级）\n第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调用与返回。 call可以直接跳到被调用函数的地址段。call与跳转指令有着分别不同的是，call保存返回的地址到栈中，当执行到ret的时候ret就会使用call保存在栈里的地址。 call用于函数的开始，ret用于函数的结束（不是所有ret都代表这函数的结束）。 int Add(int x,int y); main( ) { int a=5,b=6; Add(a,b); return 0; } Add(int x,int y) { return(x+y); } int Add(int x, int y); void main() { 003517A0 push ebp 003517A1 mov ebp,esp 003517A3 sub esp,0D8h 003517A9 push ebx 003517AA push esi 003517AB push edi 003517AC lea edi,[ebp-18h] 003517AF mov ecx,6 003517B4 mov eax,0CCCCCCCCh 003517B9 rep stos dword ptr es:[edi] 003517BB mov ecx,offset _99047FA2_源@cpp (035C000h) 003517C0 call @__CheckForDebuggerJustMyCode@4 (035130Ch) int a = 5, b = 6; 003517C5 mov dword ptr [a],5 003517CC mov dword ptr [b],6 Add(a,b); 003517D3 mov eax,dword ptr [b] 003517D6 push eax 003517D7 mov ecx,dword ptr [a] 003517DA push ecx 003517DB call Add (03511B3h) //函数的开始 003517E0 add esp,8 } int Add(int x, int y) { 00351740 push ebp 00351741 mov ebp,esp 00351743 sub esp,0C0h 00351749 push ebx 0035174A push esi 0035174B push edi 0035174C mov edi,ebp 0035174E xor ecx,ecx 00351750 mov eax,0CCCCCCCCh 00351755 rep stos dword ptr es:[edi] 00351757 mov ecx,offset _99047FA2_源@cpp (035C000h) 0035175C call @__CheckForDebuggerJustMyCode@4 (035130Ch) return (x + y); 00351761 mov eax,dword ptr [x] 00351764 add eax,dword ptr [y] } 00351767 pop edi 00351768 pop esi 00351769 pop ebx 0035176A add esp,0C0h 00351770 cmp ebp,esp 00351772 call __RTC_CheckEsp (0351235h) 00351777 mov esp,ebp 00351779 pop ebp 0035177A ret //函数的结束 2. 函数的参数 函数传参的三种方式，栈方式，寄存器方式，全局变量 利用栈方式\n栈的基础知识\n常用的调用约定 利用寄存器传参 Fastcall特点就快（因为寄存器传参的原因）\n不同编译器的Fastcall也是不一样的 Visual C++,函数参数左边2个不大于4字节（DWORD）参数放在eax，edx寄存器， 寄存器用完用栈，从从右到左压栈，子程序处理堆栈平衡。浮点值，远指针，_int64 总是栈来传递 Borland Delphi/C++ 的 Fastcall 左边3个不大于4字节（DWORD），分别放在eax，edx，ecx寄存器中其余参数按照PASCAL方式压入。 3. 函数的返回值 return返回值 一般情况下函数的返回值会放在eax中，如果处理的大小超过eax寄存器的容量，edx寄存器中。 通过参数按传引方式返回值\n传递两种方式分别是，传值，引用 - 传值，引用\n示例代码 #include \u0026lt;stdio.h\u0026gt; void max(int *a, int *b); void main() { int a = 5; int b = 6; max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 printf(\u0026#34;a,b中较大的数是：%d\u0026#34;,a); } void max(int *a, int *b) {\t//if 不带{} 就会影响下一行缩进的代码，如果下列多行代码缩进只会影响if下一行的代码，剩下的无条件执行 if (*a \u0026lt; *b) //*a 代表间接变量去到\u0026amp;a的内存地址 *a 就是取到这个内存地址为保存的的值,然后今进行比较 *a = *b; // 把*b的值赋值到*a位置 } 00B818D5 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B818DA call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) int a = 5; 00B818DF mov dword ptr [a],5 //a赋值 int b = 6; 00B818E6 mov dword ptr [b],6 //b赋值 max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 00B818ED lea eax,[b] //第二个参数 lea取的是地址 00B818F0 push eax 00B818F1 lea ecx,[a] //第一个参数 lea取的是地址 00B818F4 push ecx 00B818F5 call max (0B81280h) //调用 max 子程序 00B818FA add esp,8 （_cdecl） max()\n00B81787 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B8178C call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) if (*a \u0026lt; *b) 00B81791 mov eax,dword ptr [a] //获取a在内存中的十六进制 00B81794 mov ecx,dword ptr [b] //获取b在内存中的十六进制 00B81797 mov edx,dword ptr [eax] //edx = eax 00B81799 cmp edx,dword ptr [ecx] //判断 *a\u0026lt;*b 是否满足条件 00B8179B jge __$EncStackInitStart+2Bh (0B817A7h) //大于等于跳转 *a = *b; 00B8179D mov eax,dword ptr [a] //a 00B817A0 mov ecx,dword ptr [b] //b 00B817A3 mov edx,dword ptr [ecx] // edx=b 00B817A5 mov dword ptr [eax],edx // a = b 赋值 并且作为返回值 } 00B817A7 pop edi //跳到这什么都不改 00B817A8 pop esi 00B817A9 pop ebx 00B817AA add esp,0C0h 00B817B0 cmp ebp,esp 00B817B2 call __RTC_CheckEsp (0B8123Fh) 00B817B7 mov esp,ebp 00B817B9 pop ebp 00B817BA ret 第三章数据结构 1.局部函数 利用栈存放局部变量\n程序sub esp,8这句话就是为局部变量分配分配内存空间，用[ebp-xxxx]寻址调用这些变量，而参数调用相对于ebp偏移量正的，即[ebp+xxxx]。编译在优化模式下。 当函数退出时，用add esp, 8指令平衡栈，以释放局部变量占用的内存，有的编译器给esp 添加负值进行内存的分配，编译器也有可能会用push reg代替sub esp,4。 局部变量分配与清除栈的方式 形式一 形式二 形式三 add esp,n\n\u0026hellip;.\nsub esp,n add esp,-n\n\u0026hellip;.\nsub esp,-n push reg\n\u0026hellip;\npop reg 利用寄存器存放局部变量 int add(int x,int y); int main(void) { int a=5,b=6; add(a,b); return 0; } int add(int x,int y) { int z; z=x+y; return(z); } .text:004117B0 push ebp .text:004117B1 mov ebp, esp .text:004117B3 sub esp, 0D8h //局部变量申请的栈内存空间 .text:004117B9 push ebx .text:004117BA push esi .text:004117BB push edi .text:004117BC lea edi, [ebp+var_18] .text:004117BF mov ecx, 6 .text:004117C4 mov eax, 0CCCCCCCCh .text:004117C9 rep stosd .text:004117CB mov ecx, offset unk_41C000 .text:004117D0 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) .text:004117D5 mov [ebp+var_8], 5 //局部变量放入var_8中 .text:004117DC mov [ebp+var_14], 6 //局部变量放入var_14中 .text:004117E3 mov eax, [ebp+var_14] //取出var_14放入eax .text:004117E6 push eax .text:004117E7 mov ecx, [ebp+var_8] //取出var_8放入ecx .text:004117EA push ecx .text:004117EB call sub_4112AD .text:004117F0 add esp, 8 //平栈 _cdecl .text:004117F3 xor eax, eax .text:004117F5 pop edi .text:004117F6 pop esi .text:004117F7 pop ebx .text:004117F8 add esp, 0D8h //回收申请的栈内存空间 .text:004117FE cmp ebp, esp .text:00411800 call j___RTC_CheckEsp .text:00411805 mov esp, ebp .text:00411807 pop ebp .text:00411808 retn .text:00411808 _main_0 endp .text:00411808 利用寄存器存放局部变量 除了esp，ebp栈寄存器，其余6个通用寄存器尽可能的存放变量，这样可以减少代码提高程序的执行效率，逆向分析中局部变量生命周期短，必须及时确定当前寄存器的变量是那个变量 2.全局变量 全局变量通常位于.data段，程序访问全局变量时，一般会用固定的硬编码地址对内存地址进行寻址\n如果某个函数的改变了全局变量的值，就能影响其他函数，可以利用全局变量传递参数或者函数的返回值。 全局变量在程序的执行过程中占用内存单元，不像局部变量那样需要的时候才开辟存储单元。\n源码示例\nint z; int add(int x,int y); int main(void) { int a=5,b=6; z=7; add(a,b); return 0; } int add(int x,int y) { return(x+y+z); } main\npush ebp mov ebp, esp sub esp, 0D8h //局部变量申请空间 ....... mov ecx, 6 mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov [ebp+var_8], 5 //局部变量 mov [ebp+var_14], 6 //局部变量 mov dword_41A138, 7 //全局变量 mov eax, [ebp+var_14] push eax ...... retn add()\npush ebp mov ebp, esp sub esp, 0C0h ...... mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov eax, [ebp+arg_0] add eax, [ebp+arg_4] add eax, dword_41A138 //全局变量 pop edi ...... call j___RTC_CheckEsp mov esp, ebp pop ebp retn charGPT回答\n可以通过查看汇编代码中的内存地址来判断变量是局部变量还是全局变量。在汇编中，局部变量通常存储在堆栈中，而全局变量则存储在数据段中。通过查看变量的内存地址，如果它在堆栈范围内，则是局部变量，否则是全局变量。\n3.数组 数组在内存中是连续存放的，在汇编访问状态下访问数组一般是通过基址加变址寻址的方式实现的。\n#include \u0026lt;stdio.h\u0026gt; int main(void) { static int a[3]={0x11,0x22,0x33}; int i,s=0,b[3]; for(i=0;i\u0026lt;3;i++) { s=s+a[i]; b[i]=s; } for(i=0;i\u0026lt;3;i++) { printf(\u0026#34;%d\\n\u0026#34;,b[i]); } return 0; } .text:00401009 mov edi, dword_407030[eax] ; ;dword_407030是数组的空间位置, eax 现在是0 指向第一个元素 .text:0040100F add eax, 4 ; eax = 4 这是偏移下一次的地址指向了dword_407034 .text:00401012 add ecx, edi ; ;ecx = dword_407030 数组列表 .text:00401014 cmp eax, 0Ch ; ;if eax == 12 .text:00401017 mov [esp+eax+14h+var_10], ecx ; [esp+eax+14h+var_10] = dword_407030 .text:0040101B jl short loc_401009 ; 等于12的时候就不跳转了 .text:0040101D lea esi, [esp+14h+var_C] ; 数组列表现在到esi中了 .text:00401021 mov edi, 3 ; edi = 3 覆盖了数组元素 .text:00401026 .text:00401026 loc_401026: ; CODE XREF: _main+3A↓j .text:00401026 mov eax, [esi] ; 第二个循环 .text:00401028 push eax .text:00401029 push offset aD ; \u0026#34;%d\u0026#34; .text:0040102E call printf ; 打印一次 .text:00401033 add esp, 8 ; 栈平衡 .text:00401036 add esi, 4 ; 数组指向下一个元素 .text:00401039 dec edi ; edi = 3-1计数器 .text:0040103A jnz short loc_401026 ; 第二个循环 .text:0040103C pop edi .text:0040103D xor eax, eax .text:0040103F pop esi .text:00401040 add esp, 0Ch .text:00401043 retn .text:00401043 _main endp dword_407030\n.data:0040702C align 10h ;[0]第一个元素 .data:00407030 dword_407030 dd 11h ; DATA XREF: _main:loc_401009↑r .data:00407034 db 22h ; \u0026#34; .data:00407035 db 0 .data:00407036 db 0 .data:00407037 db 0 .data:00407038 db 33h ;最后指向的元素 .data:00407039 db 0 .data:0040703A db 0 .data:0040703B db 0 .data:0040703C aD db \u0026#39;%d\u0026#39; ; DATA XREF: _main+29↑o .data:0040703E db 0Ah .data:0040703F db 0 第四章虚函数 虚函数是在程序运行之前定义的函数，虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有的虚函数引用通常放在一个专用的数组————虚函数表，数组中的每个元素存放的就是类中的虚函数地址。\n调用虚函数时，程序先从虚函数表指针，得到函数地址，再根据取出的函数地址调用函数 对象实例 \u0026ndash;\u0026gt; 函数表 \u0026ndash;\u0026gt; 要调用的函数的地址 #include \u0026lt;stdio.h\u0026gt; class CSum { public: virtual int Add(int a, int b) { return (a + b); } virtual\tint\tSub(int a, int b ) { return (a - b); } }; void main() { CSum*\tpCSum = new CSum ; pCSum-\u0026gt;Add(1,2); pCSum-\u0026gt;Sub(1,2); } .text:00401000 push esi .text:00401001 push 4 ; Size .text:00401003 call ??2@YAPAXI@Z ; new()函数，这里决定了虚表的位置 .text:00401008 add esp, 4 .text:0040100B test eax, eax .text:0040100D jz short loc_401019 .text:0040100F mov dword ptr [eax], offset off_4050A0 ; 这是指向虚表的的指针，eax的地址存放的内容是004050A0 .text:00401015 mov esi, eax ; esi=eax的内存地址 .text:00401017 jmp short loc_40101B ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:00401019 ; --------------------------------------------------------------------------- .text:00401019 .text:00401019 loc_401019: ; CODE XREF: _main+D↑j .text:00401019 xor esi, esi .text:0040101B .text:0040101B loc_40101B: ; CODE XREF: _main+17↑j .text:0040101B mov eax, [esi] ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:0040101D push 2 .text:0040101F push 1 .text:00401021 mov ecx, esi ; ecx = esi = eax的内存地址 .text:00401023 call dword ptr [eax] ; 第一次调用函数 .text:00401025 mov edx, [esi] ; edx = 004050A0 .text:00401027 push 2 .text:00401029 push 1 .text:0040102B mov ecx, esi .text:0040102D call dword ptr [edx+4] ; 因为在内存中是连续的，所以第二次调用+4的偏移。004050A4 = 4 + (edx = 004050A0) .text:00401030 pop esi .text:00401031 retn .text:00401031 _main endp 现在可以看看004050A0这位置存放的是什么\n.rdata:004050A0 off_4050A0 dd offset sub_401040 ; DATA XREF: _main+F↑o //add函数 .rdata:004050A4 dd offset sub_401050 //sub函数 004050A0、004050A4就是不同函数的地址\n第五章控制流程语句 1. if判断 2. switch #include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 10:printf(\u0026#34;a=10\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } .text:0040100A push offset Format ; \u0026#34;%d\u0026#34; .text:0040100F call _scanf ; scanf .text:00401014 add esp, 8 ; 堆栈平衡 .text:00401017 mov ecx, [ebp+var_4] .text:0040101A mov [ebp+var_8], ecx ; switch(a) .text:0040101D cmp [ebp+var_8], 1 ; case 1: .text:00401021 jz short loc_401031 ; print .text:00401023 cmp [ebp+var_8], 2 ; case 2: .text:00401027 jz short loc_401040 .text:00401029 cmp [ebp+var_8], 0Ah ; case 10: .text:0040102D jz short loc_40104F .text:0040102F jmp short loc_40105E 优化后的\n.text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov eax, [esp+0Ch+var_4] .text:00401014 add esp, 8 .text:00401017 dec eax .text:00401018 jz short loc_401055 .text:0040101A dec eax .text:0040101B jz short loc_401044 .text:0040101D sub eax, 8 .text:00401020 jz short loc_401033 .text:00401022 push offset aADefault ; \u0026#34;a=default\u0026#34; .text:00401027 call sub_401070 .text:0040102C add esp, 4 .text:0040102F xor eax, eax 最大的区别就是原先使用的时内存寻址现在使用的是寄存器，调用寄存器确实比寻址快，就是寄存器少。\n2.2 switch跳转表 这个switch逆向有点东西，这个因为case多会生成switch跳转表再由跳转表进行跳转\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 3:printf(\u0026#34;a=3\u0026#34;); break; case 4:printf(\u0026#34;a=4\u0026#34;); break; case 5:printf(\u0026#34;a=5\u0026#34;); break; case 6:printf(\u0026#34;a=6\u0026#34;); break; case 7:printf(\u0026#34;a=7\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } 假如我们输入的的是7\n.text:00401000 push ecx .text:00401001 lea eax, [esp+4+var_4] .text:00401005 push eax .text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov ecx, [esp+0Ch+var_4] ; ecx是存放的是从缓冲区读取的内容 .text:00401014 add esp, 8 .text:00401017 lea eax, [ecx-1] ; switch 7 cases .text:0040101A cmp eax, 6 ; 判断eax是否在六case之内。大于6进行ja跳转就是default分支 .text:0040101D ja short def_40101F ; jumptable 0040101F default case .text:0040101F jmp ds:jpt_40101F[eax*4] ; switch jump 要在4010B0的地址偏移量（eax * 4 =要跳转的分支） 走到00401017就会变成6，然后到0040101A进行比较相等不会触发ja跳转， 到0040101F的时候就是(eax=6)*4 = 24然后转换成16进制得到的偏移量就是18 得到的地址就是0040108C\n.text:0040108C .text:0040108C loc_40108C: ; CODE XREF: _main+1F↑j .text:0040108C ; DATA XREF: .text:jpt_40101F↓o .text:0040108C push offset aA7 ; jumptable 0040101F case 7 这是字符串 .text:00401091 call printf .text:00401096 add esp, 4 .text:00401099 xor eax, eax .text:0040109B pop ecx .text:0040109C retn 转移指令机器码计算（跳过） 条件设置指令 （跳过） 第六章循环语句 for循环\n第七章数学运算符 1. 加法 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; printf(\u0026#34;%d\u0026#34;,a+b+0x78); return 0; } lea 是一条纯计算指令\n.text:00401000 push ecx .text:00401001 mov eax, [esp+4+var_4] ; int a .text:00401005 mov ecx, [esp+4+var_4] ; int b .text:00401009 lea edx, [ecx+eax+78h] ; 计算a+b+0x78,结果放到edx中 .text:0040100D push edx .text:0040100E push offset aD ; \u0026#34;%d\u0026#34; .text:00401013 call printf 除法（这个可以看C++反汇编大揭秘书上讲的比较好） 第八章文本字符串 1. 字符串的存储格式 C字符串：也称ASCII字符串 \u0026ldquo;Z\u0026quot;表示其以\u0026rdquo;\\0\u0026quot;为结束标识符。“\\0”代表ASCII码为0的字符。ASCII为0的字符的时候显示空操作符 DOS字符串： 以$结尾作为终止符，基本已被淘汰 PASCAL字符串：这个字符串没有终止符，而是长度符号字符串的头部定义1个字节，用于指示当前字符串的长度，字符串的长度不能过255字符。 Delphi字符串： 为了解决PASCAL 255长度限制设计的增加了对长度的支持，表示长度扩展到2字节，使字符串最大长度达到65535 四字节的Delphi: 少见，表示长度扩展到4字节字符串长度可以到达4GB 字符寻址指令 mov eax,[00401000] ;直接寻址，把00401000地址的双字节数据放到eax中 mov eax, [ecx] ;间接寻址, 即把ecx中的地址所指的内容放到eax lea eax,[00401000] ;把00401000装到eax中 ","permalink":"http://guozhi1.github.io/posts/tech/32%E4%BD%8D%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF/","summary":"前言 知识来源：《加密与解密》 第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数 （选择WinMain,交叉引用就可以找到上一级） 第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调","title":"32位逆向技术"},{"content":"调用约定 知识来源\n允许使用VARARG：表示参数个数可以是不确定\n约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall\nint Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默认调用约定 Test(1,2,3,4,5); 00A71891 push 5 00A71893 push 4 00A71895 push 3 00A71897 push 2 //第二个参宿 00A71899 push 1 //第一个参宿 00A7189B call Test (0A71398h) 00A718A0 add esp,14h //平栈由调用者执行 _cdecl从右到左进行压栈操作，由调用者进行压栈操作\n_stdcall\n_stdcall 是WindowsApi默认的调用约定 Test(1,2,3,4,5); 00271891 push 5 00271893 push 4 00271895 push 3 00271897 push 2 00271899 push 1 0027189B call Test (02713ACh) //由被调用者平栈 Test_Call\nint _stdcall Test(int a,int b,int c,int d,int e) { 00F41760 push ebp 00F41761 mov ebp,esp 00F41763 sub esp,0C0h 00F41769 push ebx 00F4176A push esi 00F4176B push edi 00F4176C mov edi,ebp 00F4176E xor ecx,ecx 00F41770 mov eax,0CCCCCCCCh 00F41775 rep stos dword ptr es:[edi] 00F41777 mov ecx,offset _99047FA2_源@cpp (0F4C029h) 00F4177C call @__CheckForDebuggerJustMyCode@4 (0F4130Ch) return a + b + c + d + e; 00F41781 mov eax,dword ptr [a] 00F41784 add eax,dword ptr [b] 00F41787 add eax,dword ptr [c] 00F4178A add eax,dword ptr [d] 00F4178D add eax,dword ptr [e] } 00F41790 pop edi 00F41791 pop esi 00F41792 pop ebx 00F41793 add esp,0C0h 00F41799 cmp ebp,esp 00F4179B call __RTC_CheckEsp (0F41235h) 00F417A0 mov esp,ebp 00F417A2 pop ebp 00F417A3 ret 14h //平栈操作 _stdcall 是从右到左进行压栈，但是平栈操作由被被调用者执行\n_fastcall 008F1891 push 6 008F1893 push 5 008F1895 push 4 008F1897 push 3 008F1899 mov edx,2 008F189E mov ecx,1 008F18A3 call Test (08F13C0h) _fastcall 比较特殊他会，从左往右压入参数，但是前两个参数会被赋值到寄存器中，然后由被调者自己平栈\nint _fastcall Test(int a,int b,int c,int d,int e,int w) { 008F1760 push ebp 008F1761 mov ebp,esp 008F1763 sub esp,0D8h 008F1769 push ebx 008F176A push esi 008F176B push edi 008F176C push ecx 008F176D lea edi,[ebp-18h] 008F1770 mov ecx,6 008F1775 mov eax,0CCCCCCCCh 008F177A rep stos dword ptr es:[edi] 008F177C pop ecx 008F177D mov dword ptr [b],edx 008F1780 mov dword ptr [a],ecx 008F1783 mov ecx,offset _99047FA2_源@cpp (08FC029h) 008F1788 call @__CheckForDebuggerJustMyCode@4 (08F130Ch) return a + b + c + d + e; 008F178D mov eax,dword ptr [a] 008F1790 add eax,dword ptr [b] 008F1793 add eax,dword ptr [c] 008F1796 add eax,dword ptr [d] 008F1799 add eax,dword ptr [e] } 008F179C pop edi 008F179D pop esi 008F179E pop ebx 008F179F add esp,0D8h 008F17A5 cmp ebp,esp 008F17A7 call __RTC_CheckEsp (08F1235h) 008F17AC mov esp,ebp 008F17AE pop ebp 008F17AF ret 10h //平栈。因为我多加了个参数导致和之前长度不一样了。 x64 下的调用约定 调用规则是由编译器决定的现在这是由VS平台下的调用约定，这是一种变形的_fastcall。\nTest(1,2,3,4,5); 00007FF631FB187B mov dword ptr [rsp+20h],5 00007FF631FB1883 mov r9d,4 00007FF631FB1889 mov r8d,3 00007FF631FB188F mov edx,2 00007FF631FB1894 mov ecx,1 00007FF631FB1899 call Test (07FF631FB13ACh) 参数从右到左,前四个参数会放到寄存器中分别是,edx,ecx,r8,r9 寄存器。 寄存器的速度是高于栈传参的速度的\nint _cdecl Test(int a,int b,int c,int d,int e) { 00007FF631FB1760 mov dword ptr [rsp+20h],r9d 00007FF631FB1765 mov dword ptr [rsp+18h],r8d 00007FF631FB176A mov dword ptr [rsp+10h],edx 00007FF631FB176E mov dword ptr [rsp+8],ecx 00007FF631FB1772 push rbp 00007FF631FB1773 push rdi 00007FF631FB1774 sub rsp,0E8h 可以看到这个r9,r8,edx,ecx又放入了栈空间，这是为什么？\n寄存器中的值放入栈预留空间，是为了防止参数传递过程中，寄存器需要接收其他值而无法传递参数，或者其他值无法接收的情况。\n仔细查看会发现x64这个调用约定是没有平栈的操作的是因为\n64位下一开始系统会为main（）函数开辟一个很大的栈区，但是main（）函数并未消耗掉这么大的栈区空间，这时候怎么办呢？子函数就会还继续利用main（）函数的栈区空间，所以main（）函数并不用对子函数栈区空间进行清理。\n","permalink":"http://guozhi1.github.io/posts/tech/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","summary":"调用约定 知识来源 允许使用VARARG：表示参数个数可以是不确定 约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall int Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默","title":"逆向基础-调用约定"},{"content":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll\n安全厂商也可以通过接入Amsi进行查杀提高安全性\n接入Amsi的相关厂商\nAMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库\nASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位置 行:1 字符: 1 + amsiutils + ~~~~~~~~~ 此脚本包含恶意内容，已被你的防病毒软件阻止。 + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : ScriptContainedMaliciousContent PS C:\\Users\\32569\u0026gt; 长度清零 先对Amsi.dll的使用IDA进行逆向，查调用函数存在一个AmsiScanBuffer函数。\n扫描充满内容的缓冲区以查找恶意软件。 HRESULT AmsiScanBuffer( [in] HAMSICONTEXT amsiContext, [in] PVOID buffer, [in] ULONG length, [in] LPCWSTR contentName, [in, optional] HAMSISESSION amsiSession, [out] AMSI_RESULT *result ); 第三个参数是设置AMSi从缓冲区读取的长度，我们可以把这个设置为0让它读不到东西。\n","permalink":"http://guozhi1.github.io/posts/tech/%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%85%8D%E6%9D%80/","summary":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll 安全厂商也可以通过接入Amsi进行查杀提高安全性 接入Amsi的相关厂商 AMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库 ASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位","title":"文本类型免杀"},{"content":"","permalink":"http://guozhi1.github.io/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"http://guozhi1.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"http://guozhi1.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客(源码来源大佬)\r小白工具箱chargpt\r非常好用的工具站\r知识星球（免费）\r做网络安全知识汇总\r小白工具箱github镜像\r非常好用的工具站\r棱角安全社区\r非常好用的工具站\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"http://guozhi1.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客(源码来源大佬) 小白工具箱chargpt 非常好用的工具站 知识星球（免费） 做网络安全知识汇总 小白工具箱github镜像 非常好用的工具站 棱角安全社区 非常好用的工具站 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求","title":"🤝友链"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"http://guozhi1.github.io/about/","summary":"关于我 英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"}]